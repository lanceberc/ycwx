<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StFYC Weather Information</title>
    <style>
      * {
	  box-sizing: border-box;
      }
      /*
      :root {
	  --rust: #844D36;
	  --plum: #474853;
	  --steel-blue: #86B3D1;
	  --light-coffee: #AAADA0;
	  --earth: #8E8268;
	  --black: black;
	  --white: white;
	  --main-background-color: #844D36;
	  --main-foreground-color: white;
	  --hover-background: white;
	  --hover-foreground: black;
      }
     */
      :root {
	  --rust: #14365D; /* Night Moon */
	  --background2: #2F5C8F; /* Deep Blue */
	  --foreground1: #A96762; /* Mauve */
	  --foreground2: #D85C27; /* Mandarin */
	  --foreground3: #B999BE; /* Lavender */
	  --black: black;
	  --white: white;
	  --medium-grey: #80808080;
	  --main-background-color: #14365D; /* Night Moon */
	  --main-foreground-color: white;
	  --hover-background: white;
	  --hover-foreground: black;
      }
      body {
	  background: var(--main-background-color);
	  font-family: Arial;
	  font-size: 16px;
	  color: var(--main-foreground-color);
	  height: 98vh;
	  width: 98vw;
	  /*max-height: 98vh;*/
	  /*max-width: 98vw;*/
	  display: flex;
      }
      .bg-active {
	  color: var(--main-foreground-color);
	  background: var(--background2);
      }
      .vertical-spacer-outer {
	  display: flex;
	  flex-direction: column;
	  flex-basis: max-content;
	  flex-grow: 1;
      }
      .vertical-spacer-inner {
	  flex-basis: max-content;
	  flex-grow: 10;
      }
      .wx-page {
	  display: flex;
	  flex-direction: column;
	  flex-wrap: nowrap;
	  flex-grow: 1;
	  flex-basis: max-content;
	  max-height: 100%;
	  max-width: 100%;
	  min-width: 0;
	  min-height: 0;
      }
      .wx-header {
	  display: grid;
	  grid-template-columns: fit-content(100%) auto fit-content(100%);
	  flex-grow: 0;
	  width: 100%;
	  align-items: center;
	  justify-items: center;
      }
      .wx-row {
	  display: flex;
	  grid-template-columns: fit-content(100%) auto;
	  grid-template-rows: fit-content(100%);
	  flex-grow: 1;
	  flex-basis: max-content;
	  max-width: 100%;
	  max-height: 100%;
	  min-width: 0;
	  min-height: 0;
      }
      .wx-sidebar {
	  display: flex;
	  flex-direction: column;
	  flex-shrink: 0;
	  flex-grow: 1;
	  flex-basis: max-content;
	  margin-top: 4px;
	  margin-right: 4px;
	  max-height: 100%;
      }
      .wx-content {
	  display: flex;
	  flex-grow: 100;
	  flex-shrink: 1;
	  flex-basis: auto;
	  max-width: 100%;
	  max-height: 100%;
	  min-width: 0;
	  min-height: 0;
      }
      .wx-scene {
	  /* width: auto; */
	  /* height: auto; */
	  /* max-width: 100%; */
	  /* max-height: 100%; */
	  margin: 2px 2px 2px 2px;
	  flex-direction: column;
	  flex-grow: 1;
	  flex-shrink: 1;
	  flex-basis: auto;
	  display: none;
	  max-width: 100%;
	  max-height: 100%;
      }
      .wx-program {
	  color: var(--main-foreground-color);
	  background: var(--foreground2);
      }
      .wx-time {
	  font-family: "Courier New";
	  color: var(--main-foreground-color);
      }
      .wx-scene-list {
	  color: var(--main-foreground-color);
	  list-style-type: none;
      }
      .wx-cell {
	  display: inline-flex;
	  flex-grow: 1;
	  flex-shrink: 1;
	  flex-basis: auto;
	  max-width: 100%;
	  max-height: 100%;
	  min-width: 0;
	  min-height: 0;
      }
      .wx-image {
	  object-fit: contain;
	  max-width: 100%;
	  max-height: 100%;
	  min-width: 0;
	  min-height: 0;
      }
      .wx-not-button {
      }
      .wx-button {
	  display: none;
	  padding: .25em;
	  border-width: 2px;
	  border-radius: 5px;
	  border-color: var(--main-foreground-color);
	  border-style: solid;
	  text-align: center;
	  width: 100%;
	  margin: 4px;
      }
      .wx-button:hover {
	  background: var(--hover-background);
	  color: var(--hover-foreground);
      }
      .scene-button {
	  border-radius: 5px;
	  padding: 5px;
      }
      .active-scene {
      }
      .active-scene:hover {
	  background: var(--hover-background);
	  color: var(--hover-foreground);
      }
      .scene-not-button {
	  color: var(--foreground2);
	  text-decoration: underline;
      }
      .show {
	  display: inline-flex;
      }
      .update5 {
      }
      .grid-item {
	  display: table-cell;
      }
      .vertical-container {
      }
      .wx-content-grid {
	  display: grid;
	  grid-template-columns: 120px auto;
      }
      .nws-column {
	  vertical-align: top;
	  height: 100vh;
	  overflow: auto;
	  
	  color: var(--main-foreground-color);
	  text-align: left;
	  margin-left: 1em;
	  margin-right: 1em;
      }
      .nws-zone-title {
	  color: var(--main-foreground-color);
	  background: var(--main-background-color);
	  font-size: 1.3vw;
      }
      .nws-zone-paragraph {
	  font-size: 1.2vw;
	  color: var(--main-foreground-color);
	  background: var(--background2);
      }
      .obs-grid {
	  display: grid;
	  grid-template-rows: 100%;
	  grid-template-columns: 100%;
	  border-collapse: collapse;
      }
      .obs-grid-row {
      }
      .obs-cell {
	  display: flex;
	  flex-direction: column;
	  text-align: left;
	  /*align-self: center;*/
	  max-height: 100%;
	  min-height: 0px;
	  max-width: 100%;
	  min-width: 0px;
      }
      .obs-table-even {
	  color: black;
	  background: lightgrey;
      }
      .obs-table-odd {
	  color: var(--main-foreground-color);
	  background: #aaada0;
      }
      .obs-table {
	  display: table;
	  font-size: 1.1vw;
	  /*border-spacing: 2px;*/
	  border-collapse: collapse;
	  flex: 0 0 auto;
      }
      .obs-header {
	  display: table-header-group;
	  color: var(--main-foreground-color);
	  background: var(--background2);
      }
      .obs-body {
	  display: table-row-group;
      }
      .obs-row {
	  display: table-row;
      }
      .obs-meta {
	  text-align: left;
      }
      .obs-table-cell {
	  display: table-cell;
	  text-align: left;
	  align-self: center;
	  padding-left: .5em;
	  padding-right: .5em;
      }
      .obs-data {
	  font-family: "Courier New";
      }
      .text-scene {
	  /* background: var(--white); */
	  /* color: var(--black); */
	  height: 90vh;
	  overflow: scroll;
	  padding: 1em;
      }
      .text-scene a:link {
	  color: var(--white);
      }
      @media (min-aspect-ratio: 4/3) {
	  .wind-grid {
	      display: grid;
	      grid-template-rows: 60% 40%;
	      grid-template-columns: 100%;
	      border-collapse: collapse;
	      width: 100%;
	      height: 100%;
	  }
	  .tides-grid {
	      display: grid;
	      grid-template-rows: 40% 60%;
	      grid-template-columns: 1fr 1fr;
	      border-collapse: collapse;
	      width: 100%;
	      height: 100%;
	  }
	  .grid-container {
	      display: grid;
	      grid-template-columns: 50% 50%;
	  }
	  .nws-column-1 {
	      display: none;
	  }
	  .nws-column-2 {
	      display: flex;
	  }
      }
      .wind-cell {
	  display: flex;
	  flex-direction: column;
	  text-align: left;
	  /*align-self: center;*/
	  max-height: 100%;
	  min-height: 0px;
	  max-width: 100%;
	  min-width: 0px;
	  margin: 2px;
      }
      .wind-row {
	  display: grid;
	  grid-template-columns: 50% 50%;
	  border-collapse: collapse;
	  width: 100%;
	  height: 100%;
      }
      .wind-plot {
	  font-size: 1.25vw;
	  max-height: 100%;
	  min-height: 0px;
	  max-width: 100%;
	  min-width: 0px;
	  background: var(--background2);
      }
      .high-wind-label {
	  /*fill: red;*/
	  /*stroke: white;*/
	  color: #FB4B39;
	  background: white;
      }

      /* Override d3's 10pt default */
      .wind-plot-wind-avg {
	  fill: var(--main-background-color);
	  stroke: var(--main-foreground-color);
	  stroke-width: 4.0;
      }
      .wind-plot-wind-gust {
	  fill: none;
	  stroke: var(--foreground2);
	  stroke-width: 4.0;
      }
      .tides-cell {
	  display: block;
	  flex-direction: column;
	  text-align: left;
	  /*align-self: center;*/
	  max-height: 100%;
	  min-height: 0px;
	  max-width: 100%;
	  min-width: 0px;
	  margin: 2px;
      }
      .tide-plot {
	  display: flex;
	  max-height: 100%;
	  min-height: 0px;
	  max-width: 100%;
	  min-width: 0px;
      }
      .tide-svg {
	  max-height: 100%;
	  min-height: 0px;
	  max-width: 100%;
	  min-width: 0px;
	  background: var(--background2);
      }
       /* Override d3's 10pt default */
      .tide-plot-now {
	  font-size: 1.25vw;
	  stroke: var(--foreground1);
	  stroke-width: 4.0;
      }
      .tide-plot-y-axis {
	  font-size: 1.25vw;
	  stroke-width: 1.0;
      }
      .tide-plot-x-axis {
	  font-size: 1vw;
	  stroke-width: 0.0;
      }
      .tide-plot-grid {
	  fill: none;
	  stroke: var(--main-foreground-color);
	  stroke-width: 1.0;
      }
      .tide-plot-tide {
	  fill: var(--background2);
	  fill: var(--main-background-color);
	  stroke: var(--main-foreground-color);
	  stroke-width: 4.0;
      }
      .tide-plot-label-group {
      }
      .tide-plot-label {
	  stroke: var(--main-foreground-color);
	  color: var(--main-foreground-color);
	  fill: var(--main-foreground-color);
      }
      .tide-plot-label-item {
	  stroke: var(--black);
	  fill: var(--black);
	  /*color: var(--main-foreground-color);*/
      }
      .tide-plot-label-background {
	  font-size: 1.25vw;
	  stroke: none;
	  fill: #c0c0c0a0;
      }
      .current-plot-label-item {
	  stroke: var(--black);
	  fill: var(--black);
	  /*color: var(--main-foreground-color);*/
      }
      .current-plot-label-background {
	  font-size: 1.25vw; /* Override d3's 10pt default */
	  stroke: none;
	  fill: #c0c0c0a0;
      }
      .current-events-content {
	  display: flex;
	  margin-left: 1vw;
      }
      .current-events-table {
	  display: table;
	  padding-left: 1vw;
	  border-collapse: collapse;
	  background: var(--background2);
	  color: var(--main-foreground-color);
      }
      .current-events-table-header {
	  display: table-header-group;
	  color: var(--foreground2);
	  background: var(--background2);
      }
      .current-events-table-body {
	  display: table-row-group;
      }
      .current-events-table-row {
	  display: table-row;
	  padding-top: 0.1vh;
	  padding-bottom: 0.1vh;
      }
      .current-events-table-cell {
	  display: table-cell;
	  padding-right: 1.0vw;
	  padding-left: 0.5vw;
      }
      .current-events-table-astral {
	  color: var(--foreground3);
      }
      .current-events-table-water {
      }
      .timelapse {
	  margin: 2px 2px 2px 2px;
	  display: flex;
	  justify-content: center;
      }
      .local-number {
	  display: inline-flex;
	  font-size: 2.5vw;
	  color: var(--main-foreground-color);
	  /*background: var(--plum);*/
	  border-bottom: 2px solid var(--main-foreground-color);
	  /*margin-bottom: 4px;*/
      }
      .burgee-small {
	  width: 100px;
	  height: 60.77px
      }
      .zpop {
	  z-index: 5;
      }
      .wx-video {
	  width: 100%;
	  height: 100%;
	  min-width: 0;
	  min-height: 0;
	  object-fit: contain;
      }

      .horizontal-center {
	  margin-left: auto;
	  margin-right: auto;
	  text-align: center;
      }
      .anemometer-cell {
	  background: var(--background2);
      }
      .anemometer-stfyc-gauge {
	  display: inline-block;
	  width: 100%;
	  margin: auto;
	  /* background: var(--background2); */
      }
      .anemometer-stfyc-arc {
	  fill: var(--background2);
      }
      .anemometer-stfyc-pointer-0 { /* gust */
	  fill: var(--foreground2);
	  stroke: var(--black);
      }
      .anemometer-stfyc-pointer-1 { /* avg */
	  fill: var(--white);
	  stroke: var(--black);
      }
      .anemometer-stfyc-gauge-label {
	  text-anchor: middle;
	  font-size: 2.0vw;
	  font-weight: bold;
	  background: var(--background2);
	  fill: var(--main-foreground-color);
      }
      .anemometer-stfyc-plot-label {
	  text-anchor: middle;
	  font-size: 2.50vw;
	  background: var(--background2);
	  fill: var(--main-foreground-color);
	  width: 100%;
      }
      .ol-label {
	  position: absolute;
	  background: var(--medium-grey);
	  z-index: 10;
	  font-family: monospace;
	  font-size: 1.4em;
	  font-weight: bold;
	  transform: translate(3em, .5em);
	  padding: 2px;
      }
      .ol-flex-fit {
	  display: flex;
	  flex: 1 1 max-content;
	  max-width: 100%;
	  max-height: 100%;
	  min-width: 0;
	  min-height: 0;
      }
      .ol-semi-transparent {
	  filter: opacity(50%);
      }
      .wxFlow-frame {
	  width: 100%;
	  height: 100%;
      }
      @media (max-aspect-ratio: 4/3) {
	  .wind-grid {
	      display: grid;
	      grid-template-columns: 100%;
	      border-collapse: collapse;
	      width: 100%;
	      height: auto;
	  }
	  .tides-grid {
	      display: grid;
	      /*grid-template-rows: 100%;
	      grid-template-columns: auto;*/
	      grid-template-columns: 100%;
	      border-collapse: collapse;
	      width: 100%;
	      height: auto;
	  }
	  .grid-container {
	      display: flex;
	      flex-direction: column;
	  }
	  .nws-column-1 {
	      display: flex;
	      flex-direction: column;
	  }
	  .nws-column-2 {
	      display: none;
	  }
      }
      .about-image {
	  max-width: 50%
      }
      .about-h2 {
	  font-size: 1.4vw;
	  color: var(--foreground2);
	  text-decoration: underline;
      }
      .about-h3 {
	  font-size: 1.2vw;
	  color: var(--foreground2);
	  text-decoration: underline;
      }
      @media (max-width: 1024px) {
	  .wx-header-1 {
	      display: none;
	  }
	  .wx-header-2 {
	      display: inline-flex;
	      flex-direction: column;
	  }
	  .local-number {
	      font-size: 4.0vw;
	  }
	  .wx-header {
	      grid-template-columns: fit-content(100%) auto fit-content(100%);
	  }
	  .burgee-left {
	      display: none;
	  }
	  .burgee-right {
	      font-size: 4.0vw;
	      height: 2em;
	      width: 4em;
	      display: inline-flex;
	  }
	  .scene-pull-down-enable {
	      /* font-size: 4.0vw; */
	      height: 2em;
	      width: 4em;
	      display: inline-flex;
	  }
	  .scene-pull-down-enable:hover {
	      background: var(--hover-background);
	      color: var(--hover-foreground);
	  }
	  .wx-sidebar {
	      display: none;
	  }
      }
      @media (min-width: 1024px) {
	  .wx-header-2 {
	      display: none;
	  }
	  .burgee-left {
	      display: inline-flex;
	      transform: scale(-1,1);
	  }
	  .burgee-right {
	      display: inline-flex;
	  }
	  .menu-icon-div {
	      display: none;
	  }
	  .scene-pull-down-enable {
	      display: none;
	  }
      }
      @media (max-aspect-ratio: 1/1) {
	  .label {
	      font-size: 2.5vw;
	  }
	  .anemometer-stfyc-gauge-label {
	      font-size: 5.00vw;
	  }
	  .anemometer-stfyc-plot-label {
	      font-size: 5.00vw;
	  }
      }
      @media (min-aspect-ratio: 1/1) {
	  .label {
	      font-size: 1.25vw;
	  }
      }
    </style>
    
    <script src="local_config.js"></script>
    <script src="dateformat.js"></script>
      
    <script src="data/lib/d3.v7.js"></script>
    <script src="data/lib/jquery-3.6.0.min.js" defer=""></script>

    <!-- Open Layers -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.0.0/legacy/ol.css">
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.0.0/legacy/ol.js"  defer=""></script>
    <!--
    <link rel="stylesheet" href="data/lib/ol.css">
    <script src="data/lib/ol.js"></script>
    -->

    <!--
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.14.1/css/ol.css" type="text/css">
	<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.14.1/build/ol.js"></script>
    -->

    <script src="gauge.js"></script>
    <script src="wind.js"></script>
    <script src="NowCOAST.js"  defer=""></script>
    <!-- <script src="currentMap.js"  defer=""></script> -->
    <script src="gis.js"  defer=""></script>

    <script>

      const magnetic_declination = +13; // Actually 13.2 or so
      
      const recent_history_hours = 6;
      
      let curScene = 0;
      let curSceneTime;
      let curProgram = 0;

      let mode = "Carousel";

      const colorSchemes = [
	  [ "#844D36", // rust
	    "#474853", // plum
	    "#86B3D1", // steel blue
	    "#AAADA0", // light coffee
	    "#8E8268", // earth?
	  ],
      ];

      const testSchedule = [
	  { "start": 00, "program": "Test" },
	  { "start": 30, "program": "Test" },
      ];

      const productionSchedule = [
	  { "start": 00, "program": "Local" },
	  { "start": 05, "program": "Images" },
	  { "start": 10, "program": "Time Lapse" },
	  { "start": 15, "program": "Local" },
	  { "start": 20, "program": "Images" },
	  { "start": 25, "program": "Time Lapse" },
	  { "start": 30, "program": "Local" },
	  { "start": 35, "program": "Images" },
	  { "start": 40, "program": "Time Lapse" },
	  { "start": 45, "program": "Local" },
	  { "start": 50, "program": "Images" },
	  { "start": 55, "program": "Time Lapse" },
      ];

      const interactiveSchedule = [
	  { "start": 00, "program": "All" },
	  { "start": 30, "program": "All" },
      ];

      let schedule = productionSchedule;

      const programs = {
	  "Local": [ // 5:00
	      { "div": "", "label": "Local", "duration": 0 },
	      { "div": "localWind", "label": "Wind", "duration": 30 },
	      { "div": "sfLocalObservations", "label": "Observations", "duration": 30 },
	      { "div": "sfTides", "label": "Tides & Currents", "duration": 30 },
	      { "div": "WeatherFlowStFYCScene", "label": "City Forecast", "duration": 30 },
	      { "div": "ZoneForecasts", "label": "NWS Forecasts", "duration": 60 },
	      { "div": "", "label": "Images", "duration": 0 },
	      { "div": "pacificSurfaceAnalysis", "label": "Surface Analysis", "duration": 20 },
	      { "div": "overlay-WestCoast", "label": "West Coast", "duration": 25 },
	      { "div": "overlay-BayDelta", "label": "Bay/Delta", "duration": 25 },
	      { "div": "", "label": "Time Lapse", "duration": 0 },
	      { "div": "video-BayDelta", "label": "- 6h Time Lapse", "duration": 50 },
	  ],
	  "Images": [ // 5:00
	      { "div": "", "label": "Local", "duration": 0 },
	      { "div": "localWind", "label": "Wind", "duration": 20 },
	      { "div": "sfLocalObservations", "label": "Observations", "duration": 20 },
	      { "div": "sfTides", "label": "Tide & Current", "duration": 30 },
	      { "div": "WeatherFlowStFYCScene", "label": "City Forecast", "duration": 30 },
	      { "div": "ZoneForecasts", "label": "NWS Forecasts", "duration": 60 },
	      { "div": "", "label": "Images", "duration": 0 },
	      { "div": "pacificSurfaceAnalysis", "label": "Surface Chart", "duration": 15 },
	      { "div": "goes-PACUS", "label": "GOES PACUS", "duration": 20 },
	      { "div": "overlay-NorthPacific", "label": "North Pacific", "duration": 20 },
	      { "div": "overlay-WestCoast", "label": "West Coast", "duration": 20 },
	      { "div": "overlay-BayDelta", "label": "Bay/Delta", "duration": 20 },
	      { "div": "", "label": "National", "duration": 0 },
	      { "div": "cloudTopsScene", "label": "IR Cloud Tops", "duration": 15 },
	      { "div": "nationalRadarScene", "label": "National Radar", "duration": 30 },
	  ],
	  "Time Lapse": [ // 5:00
	      { "div": "", "label": "Local", "duration": 0 },
	      { "div": "localWind", "label": "Wind", "duration": 30 },
	      { "div": "sfLocalObservations", "label": "Observations", "duration": 30 },
	      { "div": "sfTides", "label": "Tide & Current", "duration": 30 },
	      { "div": "WeatherFlowStFYCScene", "label": "City Forecast", "duration": 30 },
	      { "div": "", "label": "Time Lapse", "duration": 0 },
	      { "div": "video-Pacific", "label": "7d North Pacific", "duration": 60},
	      { "div": "video-WestCoast", "label": "12h West Coast", "duration": 60},
	      { "div": "video-BayDelta", "label": "6h Bay/Delta", "duration": 60 },
	  ],
	  "All": [
	      { "div": "", "label": "Local", "duration": 0 },
	      { "div": "localWind", "label": "Wind", "duration": 30 },
	      { "div": "sfLocalObservations", "label": "Observations", "duration": 15 },
	      { "div": "sfTides", "label": "Tide & Current", "duration": 15 },
	      /* { "div": "currentMapScene", "label": "SFBay Currents", "duration": 30 }, */
	      { "div": "ZoneForecasts", "label": "NWS Forecasts", "duration": 40 },
	      { "div": "WeatherFlowStFYCScene", "label": "City Forecast", "duration": 30 },
	      { "div": "WeatherFlowTinsleyScene", "label": "Tinsley Forecast", "duration": 30 },
	      { "div": "", "label": "Images", "duration": 0 },
	      { "div": "pacificSurfaceAnalysis", "label": "Surface Analysis", "duration": 10 },
	      { "div": "goes-PACUS", "label": "GOES PACUS", "duration": 10 },
	      { "div": "overlay-NorthPacific", "label": "North Pacific", "duration": 10 },
	      { "div": "overlay-WestCoast", "label": "West Coast", "duration": 5 },
	      { "div": "overlay-BayDelta", "label": "Bay/Delta", "duration": 5 },
	      { "div": "", "label": "Time Lapse", "duration": 0 },
	      { "div": "video-Pacific", "label": "7d North Pacific", "duration": 30},
	      { "div": "video-WestCoast", "label": "12h West Coast", "duration": 30},
	      { "div": "video-BayDelta", "label": "6h Bay/Delta", "duration": 30 },
	      // { "div": "purpleAir", "label": "StFYC Air Quality", "duration": 30 },
	      { "div": "", "label": "National", "duration": 0 },
	      { "div": "nationalRadarScene", "label": "National Radar", "duration": 30 },
	      { "div": "cloudTopsScene", "label": "IR Cloud Tops", "duration": 30 },
	      /* { "div": "vesselFinderScene", "label": "Local AIS", "duration": 30 }, */
	      { "div": "linksScene", "label": "Links", "duration": 30 },
	      { "div": "aboutScene", "label": "About", "duration": 30 },
	  ],
	  "Test": [
	      { "div": "sfTides", "label": "Tide & Current", "duration": 300 },
	      { "div": "sfLocalObservations", "label": "Local Obs", "duration": 30 },
	  ],
      }

      let scenes = [];

      const allScenes = [
	  { "div": "sfRadar", "label": "Radar", "duration": 60 },
	  { "div": "sfLocalObservations", "label": "Local Obs", "duration": 15 },
	  { "div": "sfTides", "label": "Tide & Current", "duration": 15 },
	  { "div": "ZoneForecasts", "label": "NWS Forecasts", "duration": 40 },
	  { "div": "goes-PACUS", "label": "GOES PACUS", "duration": 10 },
	  { "div": "pacificSurfaceAnalysis", "label": "Surface Chart", "duration": 10 },
	  { "div": "overlay-NorthPacific", "label": "North Pacific", "duration": 10 },
	  { "div": "overlay-WestCoast", "label": "West Coast", "duration": 5 },
	  { "div": "overlay-BayDelta", "label": "Bay/Delta", "duration": 5 },
	  { "div": "video-Pacific", "label": "North Pacific", "duration": 30},
	  { "div": "video-WestCoast", "label": "West Coast", "duration": 30},
	  { "div": "video-BayDelta", "label": "Bay/Delta", "duration": 30 },
      ];

      const zoneForecasts = {
	  url: "https://tgftp.nws.noaa.gov/data/raw/fz/fzus56.kmtr.cwf.mtr.txt",
	  zones: {},
      }

      // Scrolling uses jQuery because d3 doesn't have the right primitives.
      function nwsScroll(parent) {
	  const id = "#" + $(parent).attr("id");
	  const child = $(parent).children().first();
	  const cHeight = $(child).height();
	  const pHeight = $(parent).height();
	  const cId = "#" + $(child).attr("id");

	  if ((cHeight == 0) || (cHeight <= pHeight)) {
	      // Either not displayed or doesn't need scrolling
	      console.log(`nwsScroll: stop scroll parent ${id} ${pHeight}, child ${cId} ${cHeight}`);
	      $(parent).stop();
	      return;
	  }
	  
	  // Set up animation, longer transition for more text
	  let hiddenPixels = cHeight - pHeight;
	  let topOfClone = (cHeight / 2);
	  let duration = hiddenPixels * 40; // Have to dial this in somehow
	  oldScrollTop = $(id).scrollTop();
	  $(id).scrollTop(0); // Reset scroll
	  scrollTop = $(id).scrollTop();
	  console.log(`nwsScroll: reset parent ${id} ${pHeight} child ${cId} height ${cHeight} ${oldScrollTop} -> ${scrollTop}`);
	  setTimeout(function() {
	      $(id).animate(
		  {scrollTop: topOfClone},
		  duration,
		  "linear",
		  function() {
		      console.log("nwsScroll: start #" + $(this).attr("id"));
		      nwsScroll(this);
		  });
	  }, 10000); // 10 second delay before scrolling
      }

      let nwsRO = new ResizeObserver(elements => {
	  if (mode == "Interactive") {
	      return;
	  }
	  for (let e of elements) {
	      const cr = e.contentRect;
	      const id = "#" + e.target.id;
	      const eHeight = $(id).height();
	      const parent = $(id).parent();
	      const parentId = "#" + $(parent).attr("id");
	      const pHeight = $(parent).height();
	      console.log(`nwsRO: ${parentId} ${pHeight} ${id} ${eHeight}`);

	      if (eHeight == 0) {
		  // Turn off animation
		  console.log("nwsRO: stop " + parentId);
		  $(parentId).stop();
	      } else {
		  console.log("nwsRO: start " + parentId);
		  nwsScroll(parent);
	      }
	  }
      });

      let sfRadar = null;
      let sfRadarRO = new ResizeObserver(elements => {
	  for (let e of elements) {
	      const cr = e.contentRect;
	      const id = "#" + e.target.id;
	      const eHeight = $(id).height();
	      const parent = $(id).parent();
	      const parentId = "#" + $(parent).attr("id");
	      const pHeight = $(parent).height();
	      console.log(`sfRadarRO: ${parentId} ${pHeight} ${id} ${eHeight}`);
	  }
	  sfRadar.invalidateSize();
      });

      const nwsZones = [ "PZZ530", "PZZ545", "PZZ531" ];
      const nwsZoneText = {
	  "PZZ530": "",
	  "PZZ545": "",
	  "PZZ531": ""
      };

      const nwsAFDs = [ "KMTR"];
      const nwsAFDText = {
	  "KMTR": "",
      };

      function fetchNWS() {
	  for (let z of nwsZones) {
	      let url = "data/nwsZones/" + z + ".html"
	      //console.log("fetchNWS Zone " + z + " url: " + url);

	      // Load the text (should be html) into this node - clone it to make scrolling look continuous
	      d3.text(url).then(data => {
		  nwsZoneText[z] = data;

		  let html = "";
		  for (let t of nwsZones) {
		      if (html != "") {
			  html += "<p></p>"
		      }
		      html += nwsZoneText[t];
		  }
		  if (mode == "Carousel") {
		      html += "<p></p>"; // space for clone
		      html += html;
		  }
		  d3.selectAll(".nws-zone-container").html(html);
	      });
	  }
	  
	  for (let z of nwsAFDs) {
	      let url = "data/nwsZones/" + z + ".html"
	      //console.log("fetch NWS AFD " + z + " url: " + url);

	      // Load the text (should be html) into this node - clone it to make scrolling look continuous
	      d3.text(url).then(data => {
		  nwsAFDText[z] = data;

		  let html = "";
		  for (let t of nwsAFDs) {
		      if (html != "") {
			  html += "<p></p>"
		      }
		      html += nwsAFDText[t];
		  }
		  
		  if (mode == "Carousel") {
		      html += "<p></p>"; // space for clone
		      html += html;
		  }
		  d3.selectAll(".nws-afd-container").html(html);
	      });
	  }
      }

      // Conversion routines for Tempest defaults - only the forecast API converts units, the others return defaults
      function c2f(d) { return ((parseFloat(d) * (9.0/5.0)) + 32.0); }
      function mb2mb(d) { return(parseFloat(d)); }
      function m2kts(d) { return(parseFloat(d) * 1.94384); }
      function t2m(d) { return(parseFloat(d) + magnetic_declination); }

      // Convenience functions for scaling elements to the window size
      function vh(v) {
	  const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	  return (v * h) / 100;
      }

      function vw(v) {
	  const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	  return (v * w) / 100;
      }

      function vmin(v) { return Math.min(vh(v), vw(v)); }
      function vmax(v) { return Math.max(vh(v), vw(v)); }

      const tempestFieldMap = {
  	  "temp": { "field": "air_temperature", "convert": c2f, "precision": 1 },
	  "pressure": {"field": "sea_level_pressure", "convert": mb2mb, "precision": 0 },
	  //"wind": { "field": "wind_avg", "convert": m2kts, "precision": 1 },
	  //"gust": { "field": "wind_gust", "convert": m2kts, "precision": 0 },
	  "direction": {"field": "wind_direction", "convert": t2m, "precision": 0 },
      };

      const tempestStations = {
	  "St. Francis Yacht Club": {
	      "nickname": "stfyc",
	      "station_id": "74155",
	      "device_id": "198898",
	      "lat": "37.80737",
	      "lon": "-122.44625",
	      "observations" : {},
	      "json": "",
	      "forecast": "",
	      "lastTime": 0,
	  },
	  "Tinsley Island": {
	      "nickname": "tinsley",
	      "station_id": "42921",
	      "device_id": "131674",
	      "lat": "38.03598",
	      "lon": "-121.49423",
	      "observations" : {},
	      "json": "",
	      "lastTime": 0,
	  },
      }

      const tempestDeviceMap = {
	  "198898": "St. Francis Yacht Club",
	  "131674": "Tinsley Island",
      }

      const tempestStationMap = {
	  "74155": "St. Francis Yacht Club",
	  "42921": "Tinsley Island",
      }

      const tempestHistoryURL=`https://swd.weatherflow.com/swd/rest/observations?api_key=&device_id=&bucket=b&time_start=&time_end=&_=`;
      function fetchTempestHistory(station) {
  	  const ts_now = Math.floor(Date.now()/1000)
	  let url = tempestHistoryURL.replace("&device_id=", "&device_id=" + tempestStations[station].device_id);
	  url = url.replace("api_key=", "api_key=" + weatherFlow_apikey);
	  url = url.replace("&time_start=", "&time_start=" + (ts_now - 6*60*60));
	  url = url.replace("&time_end=", "&time_end=" + ts_now);
	  url = url.replace("&_=", "&_=" + ts_now);
	  console.log("Fetching history URL: " + url);
	  d3.json(url)
	      .then(
		  function(json) {
		      tempestStations[station].history_json = json;
		      tempestStations[station].observations = json.obs;
		      //plotTempestWindHistory(station);
		  },
		  function(error) {
		      console.log("Couldn't fetch Tempest data from url: " + url);
		  }
	      );
      }

      const tempestForecastURL="https://swd.weatherflow.com/swd/rest/better_forecast?api_key=&build=44&station_id=&lat=38.03598&lon=-121.49423&units_temp=f&units_wind=kts&units_pressure=mb&units_distance=mi&units_precip=in&units_other=imperial&units_direction=mph&_=";
      function fetchTempestForecast(station) {
  	  const nonce = Date.now()
	  let url = tempestForecastURL.replace("station_id=", "station_id=" + tempestStations[station].station_id)
	  url = url.replace("api_key=", "api_key=" + weatherFlow_apikey);
	  url = url.replace("&_=", "&_=" + nonce)
	  d3.json(url)
	      .then(
		  function(json) {
		      tempestStations[station].forecast_json = json;
		      tempestStations[station].forecast = json.current_conditions;
		      if ("forecast" in tempestStations[json.location_name]) {
			  plotTempestWindForecast(json.location_name);
		      }
		  },
		  function(error) {
		      console.log("Couldn't fetch Tempest data from url: " + url);
		  }
	      );
      }

      const tempestCurrentURL="https://swd.weatherflow.com/swd/rest/observations/location?api_key=&build=44&location_id=&_=";
      function fetchTempestCurrent(station) {
  	  const nonce = Date.now()
	  let url = tempestCurrentURL.replace("location_id=", "location_id=" + tempestStations[station].station_id)
	  url = url.replace("api_key=", "api_key=" + weatherFlow_apikey);
	  url = url.replace("&_=", "&_=" + nonce)
	  console.log("fetchTempestCurrent " + station);
	  d3.json(url)
	      .then(
		  function(json) {
		      console.log("fetchTempestCurrent " + station + " response");
		      if (json.obs.length > 0) {
			  const obs = json.obs[0];
			  let ts = new Date(message.obs[0] * 1000)
			  console.log("Tempest " + station + "observation message dated " + ts);
			  tempestStations[station].current = obs;
			  tempestStations[station].lastTime = message.obs[0];
			  for (const [field, f] of Object.entries(tempestFieldMap)) {
			      if (f.field in obs) {
				  let val = f.convert(obs[f.field]).toFixed(f.precision);
				  d3.selectAll("." + field + "-span-" + tempestStations[station].nickname).html(val);
				  // Kludge - update the anemometer gust value
				  /* Wind now cumes from Race Deck anemometer
				  if (tempestStations[station].nickname == "stfyc" && field == "gust") {
				      console.log("fetchTempestCurrent " + station + " update gust " + val);
				      anemometer.update(0, val);
				  }
				  */
			      }
			  }
		      }
		  })
	      .catch(error => {
		  console.log("Couldn't fetch Tempest data from url: " + url);
	      });
      }

      function plotTempestWindHistory(station) {
	  let svg, x, y, start, end;
	  let data;

	  if ((!("history_json" in tempestStations[station])) || (!("obs" in tempestStations[station].history_json))) {
	      return;
	  }
	  const obs = tempestStations[station].history_json["obs"];
	  if (obs == null) {
	      console.log("plotTempestWindHistory(): no observations for " + station);
	      return;
	  }

	  data = [];
	  start = obs[0][0];
	  end = obs[obs.length-1][0];
	  extent = end - start;
	  max_extent = (recent_history_hours * 60 * 60)
	  if (extent > max_extent) {
	      start = end - max_extent;
	  }

	  obs.forEach(function(e, i) {
	      if ((e[0] >= start) && (e[0] <= end)) {
		  data.push([new Date(e[0] * 1000), e[2], e[3]]);
	      }
	  });

	  start = new Date(start * 1000);
	  end = new Date(end * 1000);

	  d3.select(".wind-history-recent").selectAll("*").remove();
	  d3.select(".wind-history-recent").remove();

	  // The closer width & height are to the actual size, the better off we are
	  cr = d3.select("#wind-history-recent").node().getBoundingClientRect();
	  let width = 640;
	  let height = 360;
	  if ((cr.width > 0) && (cr.height > 0)) { // Values can be zero because it's a flex and nothing may have been rendered in row
	      width = cr.width;
	      height = cr.height - 20; // Kludge - space for title
	  }
	  let margin = { left: vw(1.25), top: vh(0.5), right: vw(1), bottom: vh(3.00) };

	  svg = d3.select("#wind-history-recent")
	      .append("svg")
	      .classed("wind-plot", true)
	      .classed("wind-history-recent", true)
	      .attr("viewBox",
		    -margin.left + " " +
		    -margin.top + " " +
		    (width + margin.left + margin.right) + " " +
		    (height + margin.top + margin.bottom))
	      .attr("preserveAspectRatio", "none")
	      //.attr("width", width).attr("height", height)
	      .append("g")
	      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	  
	  x = d3.scaleTime()
	      .domain([start, end])
	      .range([0, width]);

	  y = d3.scaleLinear()
	      .domain([0, 30])
	      .range([height, 0]);

	  // x-axis
	  svg.append("g")
	      .attr("transform", "translate(0," + height + ")")
	      .classed("label", true)
	      .call(d3.axisBottom(x));

	  // y-axis
	  svg.append("g")
	      .classed("label", true)
	      .call(d3.axisLeft(y)
		    .tickArguments([5]));

	  // y-axis gridlines
	  svg.append("g")			
	      .attr("class", "grid")
	      .call(d3.axisLeft(y)
		    .ticks([5])
		    .tickSize(-width)
		    .tickFormat("")
		   );
	  
	  // wind_avg
	  svg.append("path")
	      .datum(data)
	      .classed("wind-plot-wind-avg", true)
	      .attr("d", d3.area()
		    .x(function(d) { return x(d[0]) })
		    .y1(function(d) { return y(d[1]) })
		    .y0(function(d) { return y(0) })
		    .curve(d3.curveBasis)
		   );

	  // wind_gust
	  svg.append("path")
	      .datum(data)
	      .classed("wind-plot-wind-gust", true)
	      .attr("d", d3.line()
		    .x(function(d) { return x(d[0]) })
		    .y(function(d) { return y(d[2]) })
		    .curve(d3.curveBasis)
		   );
      }

      let wind24Rect = { "width": 0, "height": 0 };
      let wind120Rect = { "width": 0, "height": 0 };
      let windsNeedRender = false;
      
      function plotTempestWindForecast(station) {
	  let svg, x, y, start, end;
	  let X, Y1, Y2;
	  const now = Date.now()

	  if (!("forecast_json" in tempestStations[station])) {
	      windsNeedRender = false;
	      return;
	  }

	  /*
	  element = "wind-forecast24"
	  d3.select("." + element).selectAll("*").remove();
	  d3.select("." + element).remove();
	  
	  let pcr = d3.select("#" + element).node().parentNode.getBoundingClientRect();
	  let cr = d3.select("#" + element).node().getBoundingClientRect();
	  let labelcr = d3.select("#" + element + "-label").node().getBoundingClientRect();
	  if ((cr.width == 0) && (cr.height == 0)) {
	      return;
	  }

	  let width = wind24Rect.width;
	  let height = wind24Rect.height;
	  if (cr.width == currentRect.width) {
	      console.log(`plotTempestForecast wind24 width (${currentRect.width} x ${currentRect.height}) unchanged`);
	  } else {
	      width = cr.width;
	      height = cr.height;
	      height = pcr.height - labelcr.height;
	      let aheight = width * (9.0 / 16.0); // 16:9 aspect ratio
	      if ((aheight < height) || (pcr.height == labelcr.height)) {
		  height = aheight;
	      }
	      wind24Rect.width = width;
	      wind24Rect.height = height;
	  }
	  console.log(`plotTempestForecast wind24 ${cr.width} x ${cr.height} -> ${width} x ${height} parent ${pcr.width} x ${pcr.height} label ${labelcr.width} x ${labelcr.height}`);

	  let margin = { left: vw(1.25), top: vh(0.5), right: vw(1), bottom: vh(3.00) };
	  
	  start = new Date(now);
	  end = new Date(now + (24 * 60 * 60 * 1000));

	  svg = d3.select("#" + element)
	      .append("svg")
	      .classed("wind-plot", true)
	      .classed(element, true)
	      .attr("viewBox", -margin.left + " " + -margin.top + " " + (width + margin.left + margin.right) +" " + (height + margin.top + margin.bottom))
	      .attr("preserveAspectRatio", "none")
	      .attr("width", width).attr("height", height)
	      .append("g")
	      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	  
	  x = d3.scaleTime()
	      .domain([start, end])
	      .range([0, width]);
	  
	  y = d3.scaleLinear()
	      .domain([0, 30])
	      .range([height, 0]);

	  // x-axis
	  svg.append("g")
	      .attr("transform", "translate(0," + height + ")")
	      .classed("label", true)
	      .call(d3.axisBottom(x));

	  // y-axis
	  svg.append("g")
	      .classed("label", true)
	      .call(d3.axisLeft(y)
		    .tickArguments([5]));

	  // y-axis gridlines
	  svg.append("g")			
	      .attr("class", "grid")
	      .call(d3.axisLeft(y)
		    .ticks([5])
		    .tickSize(-width)
		    .tickFormat("")
		   );
	  
	  // wind_avg
	  svg.append("path")
	      .datum(data)
	      .classed("wind-plot-wind-avg", true)
	      .attr("d", d3.area()
		    .x(function(d) { return x(d[0]) })
		    .y1(function(d) { return y(d[1]) })
		    .y0(function(d) { return y(0) })
		    .curve(d3.curveBasis)
		   );
	  
	  // wind_gust
	  svg.append("path")
	      .datum(data)
	      .classed("wind-plot-wind-gust", true)
	      .attr("d", d3.line()
		    .x(function(d) { return x(d[0]) })
		    .y(function(d) { return y(d[2]) })
		    .curve(d3.curveBasis)
		   );
	  */

	  let data = [];
	  const forecast = tempestStations[station].forecast_json["forecast"]["hourly"];
	  forecast.map((d, i) => {
	      ts = d.time * 1000;
	      if (ts >= now) {
		  data.push([new Date(ts), d.wind_avg, d.wind_gust]);
	      }
	  });
	  
	  element = "wind-forecast120"
	  //d3.select("." + element).selectAll("*").remove();
	  //d3.select("." + element).remove();
	  d3.select("#" + element).selectAll("*").remove();
	  //d3.select("#" + element).remove();

	  pcr = d3.select("#" + element).node().parentNode.getBoundingClientRect();
	  cr = d3.select("#" + element).node().getBoundingClientRect();
	  labelcr = d3.select("#" + element + "-label").node().getBoundingClientRect();
	  if ((cr.width == 0) && (cr.height == 0)) {
	      return;
	  }

	  width = wind120Rect.width;
	  height = wind120Rect.height;
	  if (cr.width == currentRect.width) {
	      console.log(`plotTempestForecast wind120 width (${currentRect.width} x ${currentRect.height}) unchanged`);
	  } else {
	      width = cr.width;
	      height = cr.height;
	      height = pcr.height - labelcr.height;
	      let aheight = width * (9.0 / 16.0); // 16:9 aspect ratio
	      if ((aheight < height) || (pcr.height == labelcr.height)) {
		  height = aheight;
	      }
	      wind120Rect.width = width;
	      wind120Rect.height = height;
	  }
	  console.log(`plotTempestForecast wind120 ${cr.width} x ${cr.height} -> ${width} x ${height} parent ${pcr.width} x ${pcr.height} label ${labelcr.width} x ${labelcr.height}`);

	  margin = { left: vw(1.25), top: vh(0.5), right: vw(1), bottom: vh(3.00) };

	  // Take these from above
	  //margin = { left: vw(1.25), top: vh(0.5), right: vw(1), bottom: vh(2.75) };
	  //width = 640;
	  //height = 360;
      	  svg = d3.select("#wind-forecast120")
	      .append("svg")
	      .classed("wind-plot", true)
	      .classed("wind-forecast120", true)
	      .attr("viewBox", -margin.left + " " + -margin.top + " " + (width + margin.left + margin.right) +" " + (height + margin.top + margin.bottom))
	      .attr("preserveAspectRatio", "none")
	      .attr("width", width).attr("height", height)
	      .append("g")
	      .attr("transform",
		    "translate(" + margin.left + "," + margin.top + ")");
	  
	  start = new Date(now);
	  end = new Date(now + (120 * 60 * 60 * 1000));
	  
	  x = d3.scaleTime()
	      .domain([start, end])
	      .range([0, width]);
	  
	  y = d3.scaleLinear()
	      .domain([0, 30])
	      .range([height, 0]);

	  // x-axis
	  svg.append("g")
	      .attr("transform", "translate(0," + height + ")")
	      .classed("label", true)
	      .call(d3.axisBottom(x));

	  // y-axis
	  svg.append("g")
	      .classed("label", true)
	      .call(d3.axisLeft(y)
		    .tickArguments([5]));

	  // y-axis gridlines
	  svg.append("g")			
	      .attr("class", "grid")
	      .call(d3.axisLeft(y)
		    .ticks([5])
		    .tickSize(-width)
		    .tickFormat("")
		   );

	  // wind_avg
	  svg.append("path")
	      .datum(data)
	      .classed("wind-plot-wind-avg", true)
	      .attr("d", d3.area()
		    .x(function(d) { return x(d[0]) })
		    .y1(function(d) { return y(d[1]) })
		    .y0(function(d) { return y(0) })
		    .curve(d3.curveBasis)
		   );

	  // wind_gust
	  svg.append("path")
	      .datum(data)
	      .classed("wind-plot-wind-gust", true)
	      .attr("d", d3.area()
		    .x(function(d) { return x(d[0]) })
		    .y1(function(d) { return y(d[2]) })
		    .y0(function(d) { return y(0) })
		    .curve(d3.curveBasis)
		   );
      };

      let tidesRO = new ResizeObserver(elements => {
	  plotTides();
      });

      let currentsRO = new ResizeObserver(elements => {
	  plotCurrents();
      });

      let windRO = new ResizeObserver(elements => {
	  windPlotHistory("wind-history-recent", windHistory, (highWindMode == true) ? 45 : 30);
	  windStartStopHistory(elements[0]);
	  plotTempestWindForecast("St. Francis Yacht Club");
      });

      let anemometer = null;
      let highWindMode = false;
      let highWindTime = false;
      let highWindCurScene = null;

      // defined in local_config.js
      // let highWindThreshhold = 25;
      // let highWindDuration = 60 * 1000; // One minute

      tempestSocket = null;
      tempestSocketInitializing = false;

      function tempestError(e) {
	  console.log("tempestMessage error ");
      }

      function tempestClose(e) {
	  console.log("tempestClose() websocket closed - sleeping");
	  setTimeout(function() {
	      console.log("tempestClose() trying to reopen websocket");
	      initializeTempestStreams();
	  }, 60 * 1000); // try again in a minute
      }

      function tempestCheck() {
	  if (tempestSocket.readyState != 1) {
	      console.log("tempestCheck() ready state: " + tempestSocket.readyState);
	  }

	  if (tempestSocket.readyState == 3) {
	      initializeTempestStreams();
	  }
      }

      // https://weatherflow.github.io/Tempest/api/ws.html
      obs_stMap = {
	  //"wind": 2,
	  //"gust": 3,
	  "direction": 4,
	  "temp": 7,
      }
      
      function tempestMessage(raw) {
	  const message = JSON.parse(raw.data);
	  // console.log("tempestMessage type " + message.type + " msg " + raw.data);
	  if (message.type == "obs_st") {
	      //console.log("tempestMessage type " + message.type + " msg " + raw.data);
	      let ts = message.obs[0][0];
	      let device_id = message.device_id;
	      let station = tempestStations[tempestDeviceMap[device_id]];
	      let nickname = station.nickname;
	      // console.log("tempestMessage (" + nickname + ") type " + message.type + " msg " + raw.data);
	      station.lastTime = ts;
	      now = Math.floor(Date.now() / 1000);
	      if (now < ts + tempestValidTimespan) {
		  for (const [f, i] of Object.entries(obs_stMap)) {
		      const fm = tempestFieldMap[f];
		      const val = fm.convert(message.obs[0][i]).toFixed(fm.precision);
		      d3.selectAll("." + f + "-span-" + nickname).html(val);
		      /*
			if (nickname == "stfyc" && f == "gust") { // Kludge
			anemometer.update(0, val);
			}
		      */
		  }
	      } else {
		  nts = new Date(ts * 1000);
		  console.log("Tempest " + nickname + " stale obs_st message dated " + nts);
	      }
	  } else if (message.type == "rapid_wind") {
	      let device_id = message.device_id;
	      let station = tempestStations[tempestDeviceMap[device_id]];
	      let nickname = station.nickname;
	      /*
	      let fm = tempestFieldMap["wind"];
	      let wind = fm.convert(message.ob[1]).toFixed(fm.precision);

	      if (nickname == "stfyc") { // Kludge
		  //d3.selectAll(".stfyc-anemometer-value-1").each(function(e, i) { this.value = wind; d3.select(this).on('change')(this); } );
		  anemometer.update(1, wind);
	      }
	      */
	      fm = tempestFieldMap["direction"];
	      let direction = fm.convert(message.ob[2]).toFixed(fm.precision);
	      //d3.selectAll(".wind-span-" + nickname).html(wind);
	      d3.selectAll(".tempest-direction-span-" + nickname).html(direction);
	  } else if (message.type == "connection_opened") {
	  } else {
	      console.log("tempestMessage unknown message type: " + message.type);
	  }
      }
      
      function initializeTempestStreams() {
	  if (tempestSocketInitializing == null) {
	      tempestSocketInitializing = new Date().now;
	  } else {
	      let now = Date.now();
	      if (now - tempestSocketInitializing < (60 * 1000)) {
		  console.log("initializeTempestStreams() in process");
		  return;
	      }
	      tempestSocketInitializing = new Date().now;
	  }
	  
	  console.log("initializeTempestStreams()");
	  url = "wss://swd.weatherflow.com/swd/data?api_key=&app=web".replace("api_key=", "api_key=" + weatherFlow_apikey);
	  tempestSocket = new WebSocket(url);
	  tempestSocket.addEventListener('onerror', tempestError);
	  tempestSocket.addEventListener('onclose', tempestClose);
	  tempestSocket.addEventListener('message', tempestMessage);
	  tempestSocket.addEventListener('open', function(e) {
	      // Request StFYC events + rapid_wind
	      let device_id = tempestStations["St. Francis Yacht Club"].device_id;
	      let station_id = tempestStations["St. Francis Yacht Club"].station_id;
	      tempestSocket.send(JSON.stringify({"type": "listen_start", "device_id": device_id}));
	      tempestSocket.send(JSON.stringify({"type": "listen_rapid_start", "device_id": device_id}));
	      tempestSocket.send(JSON.stringify({"type": "listen_start_events", "station_id": station_id}));
	      // Request Tinsley events for tempurature
	      station_id = tempestStations["Tinsley Island"].station_id;
	      device_id = tempestStations["Tinsley Island"].device_id;
	      tempestSocket.send(JSON.stringify({"type": "listen_start", "device_id": device_id}));
	      tempestSocket.send(JSON.stringify({"type": "listen_rapid_start", "device_id": device_id}));
	      tempestSocket.send(JSON.stringify({"type": "listen_start_events", "station_id": station_id}));
	  });
      }

      var windHistory = null;
      
      function stfycWindCallback(json) {
	  const wind = JSON.parse(json);
	  //console.log("wind update " + wind);
	  if (wind.event == "airmar_update") {
	      const speed_avg = wind.speed_avg.toFixed(1);
	      const gust = wind.gust.toFixed(1);
	      const dir = wind.dir.toFixed(0);
	      const dir_avg = wind.dir_avg.toFixed(0);
	      anemometer.update(1, speed_avg);
	      anemometer.update(0, gust);
	      if (gust > highWindThreshhold) {
		  if (highWindMode == false) {
		      highWindCurScene = curScene;
		      d3.selectAll(".wx-scene").classed("show", false);
		      d3.selectAll("#localWind").classed("show", true);
		  }
		  highWindMode = true;
		  highWindTime = Date.now();
	      } else {
		  if (highWindMode && (Date.now() > highWindTime + highWindDuration)) {
		      highWindMode = false;
		      // Resume regular programming
		      initializeScene(highWindCurScene);
		  }
	      }
	      d3.selectAll(".wind-span-stfyc").html(speed_avg);
	      d3.selectAll(".gust-span-stfyc").html(gust);
	      d3.selectAll(".direction-span-stfyc").html(dir);
	      d3.selectAll(".direction-avg-span-stfyc").html(dir_avg);
	  }
	  if (wind.event == "airmar_history") {
	      windHistory = wind.history;
	      windPlotHistory("wind-history-recent", windHistory, (highWindMode == true) ? 45 : 30);
	      d3.selectAll(".baro-span-stfyc").html(wind.baro);
	      d3.selectAll(".temperature-span-stfyc").html(wind.temp);
	  }

	  if (wind.event == "tempest_update") {
	      const speed_avg = wind.speed_avg.toFixed(1);
	      const gust = wind.gust.toFixed(1);
	      const dir = wind.dir.toFixed(0);
	      const dir_avg = wind.dir_avg.toFixed(0);
	      if (typeof tempest_anemometer !== 'undefined') {
		  tempest_anemometer.update(1, speed_avg);
		  tempest_anemometer.update(0, gust);
	      }
	      d3.selectAll(".tempest-wind-span-stfyc").html(speed_avg);
	      d3.selectAll(".tempest-gust-span-stfyc").html(gust);
	      d3.selectAll(".tempest-awa-span-stfyc").html(dir);
	      d3.selectAll(".tempest-awa-avg-span-stfyc").html(dir_avg);
	  }

	  if (wind.event == "tempest_history") {
	      d3.selectAll(".tempest-baro-span-stfyc").html(wind.baro.toFixed(0));
	      d3.selectAll(".tempest-temperature-span-stfyc").html((wind.temp * (9.0 /5.0) + 32.0).toFixed(1));
	      /*
	      windHistory = wind.history;
	      windPlotHistory("tempest-wind-history-recent", windHistory);
	      */
	  }
      }

      let localObs = {
	  "tableId": "sfLocalObservationsTable",
	  "url": "https://api.synopticdata.com/v2/stations/latest?stid=&units=english,speed|kts,pres|mb&showemptystations=1&token=".replace("token=", "token=" + synopticData_apitoken),
	  "stations": ["FTPC1", "PXOC1", "AISC1", "GGBC1", "46026", "46012", "46013", "CF131", "KSFO", "KOAK", "KSJC", "KHAF"],
	  "nickNames": {
	      "FTPC1": "Ft Point",
	      "PXOC1": "SF Pier 1",
	      "AISC1": "Pt Blunt",
	      "GGBC1": "GGBridge Midspan",
	      "CF131": "I5 near Tinsley Is",
	      "KSFO": "SFO",
	      "KOAK": "Oakland Airport",
	      "KSJC": "San Jose Airport",
	      "KHAF": "Half Moon Bay",
	      "46026": "46026 SF Buoy",
	      "46012": "46012 HMB Buoy",
	      "46013": "46013 Bodega",
	  },
	  "fieldMap": {
	      "temp": "air_temp_value_1",
	      "pressure": "pressure_value_1",
	      "seaLevelPressure": "sea_level_pressure_value_1",
	      "wind": "wind_speed_value_1",
	      "gust": "wind_gust_value_1",
	      "direction": "wind_direction_value_1",
	      "waterTemp": "T_water_temp_value_1",
	      "waveHeight": "wave_height_value_1",
	      "wavePeriod": "wave_period_value_1",
	      "primarySwellHeight": "primary_swell_wave_height_value_1",
	      "primarySwellDirection": "primary_swell_true_direction_value_1",
	      "primarySwellPeriod": "primary_swell__wave_period_value_1",
	  },
	  "displayFields": [
	      { "field": "id", "label": "Station", "style": "obs-meta" },
	      { "field": "name", "label": "Name", "style": "obs-meta" },
	      { "field": "time", "label": "Time", "style": "obs-data" },
	      { "field": "temp", "label": "Temp<br>(&#176;F)", "style": "obs-data" },
	      { "field": "pressure", "label": "Press<br>(mb)", "style": "obs-data" },
	      { "field": "seaLevelPressure", "label": "MSLP<br>(mb)", "style": "obs-data" },
	      { "field": "wind", "label": "Wind<br>(Kts)", "style": "obs-data" },
	      { "field": "gust", "label": "Gust<br>(Kts)", "style": "obs-data" },
	      { "field": "direction", "label": "Dir<br>(&#176;T)", "style": "obs-data" },
	      { "field": "waterTemp", "label": "WTemp<br>(&#176;F)", "style": "obs-data" },
	      { "field": "waveHeight", "label": "Wave<br>Height", "style": "obs-data" },
	      { "field": "wavePeriod", "label": "Wave<br>Period", "style": "obs-data" },
	  ],
	  "observations": {}
      }

      // Tempest stations are a bit flakey - if the Tempest is down, use NOAA data
      tempestValidTimespan = 60 * 60; /* secs a tempest observation is valid - after that use NOAA */
      backupFields = [
	  { "stid": "FTPC1", "tempest": "St. Francis Yacht Club", "tempestField": "temp", "localField": "temp", "precision": 1 },
	  // Fort Point and Pier 1 don't have baromoters - there's probably a better choice than the buoy
	  { "stid": "46026", "tempest": "St. Francis Yacht Club", "tempestField": "tempest-baro", "localField": "pressure", "precision": 0 },
	  { "stid": "CF131", "tempest": "Tinsley Island", "tempestField": "temp", "localField": "temp", "precision": 1  },
      ];

      function handleObs(json) {
	  let intervalStart = 0;
	  let lastObservation;
	  let STID;
	  
	  function checkObs(station, f) {
	      let val = ""
	      if (f in json["STATION"][station]["OBSERVATIONS"]) {
		  const t = json["STATION"][station]["OBSERVATIONS"][f]["date_time"]
		  const ms = Date.parse(t)
		  if (ms > intervalStart) {
		      if (ms > lastObservation) {
			  lastObservation = ms;
		      }
		      val = json["STATION"][station]["OBSERVATIONS"][f]["value"]
		  } else {
		      // console.log(STID + " Field " + f + " " + t + " too old")
		  }
	      } else {
		  // console.log("Key " + f + " not found in observations")
	      }
	      return(val);
	  }

	  //console.log("Received SynopticData observations");

	  // Buoys are not reporting updated times but have updated values. This is weird or broken.
	  intervalStart = Date.now() - (24 * 60 * 60 * 1000) // If observation was in the last 24 hours
	  const tt = new Date()
	  tt.setTime(intervalStart)

	  //console.log("Interval starts at " + tt.toUTCString())
	  
	  for (let station =  0; station < json["STATION"].length; station++) {
	      lastObservation = 0
	      STID = json["STATION"][station]["STID"];

	      localObs["observations"][STID] = {}
	      let name = (STID in localObs["nickNames"]) ? localObs["nickNames"][STID] : json["STATION"][station]["NAME"];
	      localObs["observations"][STID]["name"] = name;
	      for (let k in localObs["fieldMap"]) {
		  localObs["observations"][STID][k] = checkObs(station, localObs["fieldMap"][k])
	      }

	      // We could disable displaying non-reporting stations here
	      // Look for the newest reported datum - a bit kludgey
	      let tstring = ""
	      if (lastObservation != 0) {
		  tt.setTime(lastObservation);
		  tstring = tt.toTimeString().substr(0, 5);
	      }
	      localObs["observations"][STID]["time"] = tstring;

	      let stid;
	      firstCharacter = STID.charAt(0);
	      if (((firstCharacter >= 'A') && (firstCharacter <= 'Z')) || ((firstCharacter >= 'a') && (firstCharacter <= 'z'))) {
		  stid = STID;
	      } else {
		  stid = 'B' + STID;
	      }

	      for (let f = 0; f < localObs["displayFields"].length; f++ ) {
		  const field = localObs["displayFields"][f]["field"];
		  if (field != "id") {
		      const id = stid + '_' + field;
		      d3.select("#" + id).html(localObs["observations"][STID][field])
		  }
	      }
	  }

	  // If a Tempest hasn't reported recently use NOAA data
	  now = Math.floor(Date.now()/1000); // now in seconds
	  for (const i in backupFields) {
	      const b = backupFields[i];
	      const station = b.tempest;
	      if (tempestStations[station].lastTime < (now - tempestValidTimespan)) {
		  const stid = b.stid;
		  const lfield = b.localField;
		  const tfield = b.tempestField;
		  let val = localObs["observations"][stid][lfield];
		  if (Number.isFinite(val)) {
		      val = val.toFixed(b.precision) + "*";
		  } else {
		      val = "*";
		  }
		  const nickname = tempestStations[station].nickname;
		  console.log("handleObs() Use NOAA in place of stale Tempest datum " + station + " -> " + stid + " " + tfield + " -> " + lfield + "(" + val + ")");
		  const classString = "." + tfield + "-span-" + nickname;
		  // console.log("handleObs() classString " + classString);
		  d3.selectAll(classString).html(val);
	      }
	  }
      }

      function fetchObs(c) {
	  const nonce = Date.now()
	  if (c["stations"].length == 0) {
	      return;
	  }
	  
	  let stns = c["stations"][0]
	  for (i = 1; i < c["stations"].length; i++) {
	      stns += "," + c["stations"][i]
	  }
	  const url = c["url"].replace("stid=", "stid=" + stns);
	  d3.json(url)
	      .then(handleObs,
		    function(error) { console.log("Couldn't fetch weather from url: " + url) }
		   );
      }

      const noaaTideStation = "9414290";
      const minTide = -1.5;
      const maxTide = 6.5;
      let tideData = null;

      let tideRect = { "width": 0, "height": 0};

      function plotTides() {
	  if (tideData == null) {
	      return;
	  }
	  const tides = tideData.tides;
	  const hilo = tideData.hilo;

	  const element = "tide-forecast-" + noaaTideStation;
	  // The closer width & height are to the actual size, the better off we are
	  let pcr = d3.select("#" + element).node().parentNode.getBoundingClientRect();
	  let cr = d3.select("#" + element).node().getBoundingClientRect();
	  let labelcr = d3.select("#" + element + "-label").node().getBoundingClientRect();
	  if ((cr.width == 0) && (cr.height == 0)) {
	      return;
	  }
	  let width = tideRect.width;
	  let height = tideRect.height;
	  if (cr.width == tideRect.width) {
	      console.log(`plotTides width (${tideRect.width} x ${tideRect.height}) unchanged`);
	  } else {
	      width = cr.width;
	      height = cr.height;
	      height = pcr.height - labelcr.height;
	      let aheight = width * (9.0 / 16.0); // 16:9 aspect ratio
	      if ((aheight < height) || (pcr.height == labelcr.height)) {
		  height = aheight;
	      }
	      tideRect.width = width;
	      tideRect.height = height;
	  }
	  console.log(`plotTides ${cr.width} x ${cr.height} -> ${width} x ${height} parent ${pcr.width} x ${pcr.height} label ${labelcr.width} x ${labelcr.height}`);

	  let margin = { left: vw(1.25), top: vh(0.5), right: vw(1), bottom: vh(3.00) };

	  let X = tides.map(function(d) { return(Date.parse(d.t)) });
	  let Y = tides.map(function(d) { return(d.v) });
	  let data = X.map(function(e, i) {
	      return [e, Y[i]];
	  });
	  start = X[0];
	  end = X[X.length-1];

	  d3.select("." + element).selectAll("*").remove();
	  d3.select("." + element).remove();
	  let svg = d3.select("#" + element)
	      .append("svg")
	      .classed("tide-svg", true)
	      .classed(element, true)
	      .attr("viewBox",
		    -margin.left + " " +
		    -margin.top + " " +
		    (width + margin.left + margin.right) + " " +
		    (height + margin.top + margin.bottom))
	      .attr("preserveAspectRatio", "none")
	      .attr("width", width).attr("height", height)
	      .append("g")
	      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	  
	  x = d3.scaleTime()
	      .domain([new Date(start), new Date(end)])
	      .range([0, width]);

	  y = d3.scaleLinear()
	      .domain([minTide, maxTide])
	      .range([height, 0]);

	  // x-axis
	  svg.append("g")
	      .attr("transform", "translate(0," + height + ")")
	      .classed("tide-plot-x-axis", true)
	      .call(d3.axisBottom(x));

	  // y-axis
	  svg.append("g")
	      .classed("tide-plot-y-axis", true)
	      .call(d3.axisLeft(y)
		    .tickArguments([parseInt((maxTide - minTide) - 1)]));

	  // y-axis gridlines
	  svg.append("g")			
	      .classed("tide-plot-grid", true)
	      .call(d3.axisLeft(y)
		    .tickSize(-width)
		    .tickFormat("")
		    .ticks([parseInt((maxTide - minTide) - 1)])
		   );
	  
	  // Tide height
	  svg.append("path")
	      .datum(data)
	      .classed("tide-plot-tide", true)
	      .attr("d", d3.area()
		    .x(function(d) { return x(d[0]) })
		    .y1(function(d) { return y(d[1]) })
		    .y0(function(d) { return y(minTide) })
		    .curve(d3.curveBasis)
		   );

	  // Highs & Lows
	  const hl = [];
	  for (i in hilo) {
	      const item = hilo[i];
	      t = (new Date(item.t)).getTime();
	      if ((t > start) && (t < end)) {
		  hl.push(t);
	      }
	  }
	  svg.append("g")			
	      .classed("tide-plot-grid", true)
	      .call(d3.axisBottom(x)
		    .tickSize(height)
		    .tickFormat("")
		    .tickValues(hl)
		   );

	  // Now
	  now = Date.now();
	  svg.append("path")
	      .datum([[now, minTide], [now, maxTide]])
	      .classed("tide-plot-now", true)
	      .attr("d", d3.line()
		    .x(function(d) { return x(d[0]) })
		    .y(function(d) { return y(d[1]) })
		   );

	  X = hilo.map(function(d) { return(Date.parse(d.t)); });
	  Y = hilo.map(function(d) { return(d.v); });
	  data = [];
	  for (i in X) {
	      if ((X[i] > start) && (X[i] < end)) {
		  let label = (parseFloat(hilo[i].v).toFixed(1) + "ft @" + hilo[i].t.slice(11));
		  data.push([X[i], parseFloat(Y[i]), label, hilo[i].type]);
	      }
	  }

	  // Keep the labels on the chart during extreme tide events
	  function labelClamp(y) {
	      const labelMax = maxTide - 0.5;
	      const labelMin = minTide + 0.8;
	      if (y > labelMax) {
		  return(labelMax);
	      }
	      if (y < labelMin) {
		  return(labelMin);
	      }
	      return(y);
	  }
	  
	  // High/Low Labels
	  svg.append("g")
	      .classed("tide-plot-label-group", true)
	      .selectAll('text')
	      .data(data)
	      .enter()
	      .append("g")
	      .attr("opacity", 1)
	      .classed("tide-plot-label", true)
	      .classed("label", true)
	      .attr("transform", function(d, i) {
		  return("translate(" + x(d[0]) + ", " + y(labelClamp(d[1])) + ")")
	      })
	      .append('text')
	      .classed("tide-plot-label-item", true)
	      .classed("label", true)
	      .attr("text-anchor", "middle")
	      .attr("dx", 0)
	      .attr("dy", function(d, i) { return(d[3] == "H" ? "-0.45em" : "1.3em") } )
	      .text(function(d, i) { return(d[2]); });

	  d3.selectAll(".tide-plot-label-item").each(function(e, i) {
	      let label = d3.select(this);
	      let parent = this.parentNode;
	      let bbox = label.node().getBBox();
	      d3.select(parent).insert("rect", ":first-child")
	          .attr("x", function(d, i){return bbox.x})
		  .attr("y", function(d, i){return bbox.y})
		  .attr("dx", 0)
		  .attr("dy", function(d,i) { return(data[i][3] == "H" ? "-0.4em" : "1.3em") } )
		  .attr("width", function(d){return bbox.width})
		  .attr("height", function(d){return bbox.height})
		  .classed("tide-plot-label-background", true);
	  });
      }

      const days = [
	  "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
      ];

      const noaaCurrentStation = "SFB1203_18";
      const minCurrent = -4.5;
      const maxCurrent = 4.5;

      let currentRect = { "width": 0, "height": 0};
      
      function plotCurrents() {
	  if (tideData == null) {
	      return;
	  }
	  
	  const current_data = tideData.current_points;
	  const current_events = tideData.current_info.events; // See what I did there?

	  t = new Date();
	  let year = t.getFullYear().toString();
	  let month = (t.getMonth() < 9 ? "0" : "") + (t.getMonth()+1).toString();
	  let date = (t.getDate() < 10 ? "0" : "") + t.getDate().toString();
	  start_string = `${year}-${month}-${date} 00:00`;
	  start = new Date(start_string);

	  t.setTime(t.getTime() + (2 * 24 * 60 * 60 * 1000));
	  year = t.getFullYear().toString();
	  month = (t.getMonth() < 9 ? "0" : "") + (t.getMonth()+1).toString();
	  date = (t.getDate() < 10 ? "0" : "") + t.getDate().toString();
	  end_string = `${year}-${month}-${date} 00:00`;
	  end = new Date(end_string);

	  const plot_events = [];
	  current_events.forEach(function(e, i) {
	      if ((e.e == "Max Flood") || (e.e == "Max Ebb")) {
		  plot_events.push(e);
	      }
	  });

	  let element = ".current-events-table-" + noaaCurrentStation;
	  d3.selectAll(element).remove();

	  let today = current_events[0].t.slice(0,10);

	  let current_tables = [{},{}];
	  for (i in [0, 1]) {
	      let t0 = new Date(today + " 00:00");
	      let t = new Date();
	      const oneDay = (i * 24 * 60 * 60 * 1000);
	      t.setTime(t0.getTime() + oneDay);
	      year = t.getFullYear().toString();
	      month = (t.getMonth() < 9 ? "0" : "") + (t.getMonth()+1).toString();
	      date = (t.getDate() < 10 ? "0" : "") + t.getDate().toString();
	      head_string = days[t.getDay()] + `, ${year}-${month}-${date}`;

	      let table = d3.select("#current-events-content-" + noaaCurrentStation).append("div")
		  .classed("current-events-table", true)
		  .classed("current-events-table-" + noaaCurrentStation, true)
		  .classed("label", true);

	      let header = table.append("div")
		  .classed("current-events-table-header", true)
	      header.append("div")
		  .classed("current-events-table-cell", true)
		  .html(head_string);
	      
	      let body = table.append("dev")
		  .classed("current-events-table-body", true)
	      current_tables[i].body = body;
	  }
	  
	  current_events.forEach(function(e) {
	      const d = e.t.slice(0,10);
	      const i = (d == today) ? 0 : 1;

	      const v = (e.e.search("Slack") == -1) ? e.e : "Slack";
	      const water = (e.e.search("Slack") != -1) || (e.e.search("Max") != -1);
	      let row = current_tables[i].body.append("div")
		  .classed("current-events-table-row", true)
	      row.append("div")
		  .classed("current-events-table-cell", true)
		  .classed("current-events-table-water", water)
		  .classed("current-events-table-astral", !water)
		  .html(e.t.slice(10));
	      row.append("div")
		  .classed("current-events-table-cell", true)
		  .classed("current-events-table-water", water)
		  .classed("current-events-table-astral", !water)
		  .html(v);
	  });

	  element = "current-forecast-" + noaaCurrentStation;
	  let pcr = d3.select("#" + element).node().parentNode.getBoundingClientRect();
	  let cr = d3.select("#" + element).node().getBoundingClientRect();
	  let labelcr = d3.select("#" + element + "-label").node().getBoundingClientRect();
	  if ((cr.width == 0) && (cr.height == 0)) {
	      return;
	  }

	  let width = currentRect.width;
	  let height = currentRect.height;
	  if (cr.width == currentRect.width) {
	      console.log(`plotCurrents width (${currentRect.width} x ${currentRect.height}) unchanged`);
	  } else {
	      width = cr.width;
	      height = cr.height;
	      height = pcr.height - labelcr.height;
	      let aheight = width * (9.0 / 16.0); // 16:9 aspect ratio
	      if ((aheight < height) || (pcr.height == labelcr.height)) {
		  height = aheight;
	      }
	      currentRect.width = width;
	      currentRect.height = height;
	  }
	  console.log(`plotCurrents ${cr.width} x ${cr.height} -> ${width} x ${height} parent ${pcr.width} x ${pcr.height} label ${labelcr.width} x ${labelcr.height}`);
	  
	  let margin = { left: vw(1.25), top: vh(0.5), right: vw(1), bottom: vh(3.00) };
	  let X = current_data.map(function(d) { return(Date.parse(d[0])) });
	  let Y = current_data.map(function(d) { return(d[1]) });
	  let data = X.map(function(e, i) {
	      return [e, Y[i]];
	  });

	  d3.select("#" + element).selectAll("*").remove();
	  //d3.select("." + element).remove();
	  svg = d3.select("#" + element)
	      .append("svg")
	      .classed("tide-svg", true)
	      .classed(element, true)
	      .attr("viewBox",
		    -margin.left + " " +
		    -margin.top + " " +
		    (width + margin.left + margin.right) + " " +
		    (height + margin.top + margin.bottom))
	      .attr("preserveAspectRatio", "none")
	      .attr("width", width).attr("height", height)
	      .append("g")
	      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	  
	  x = d3.scaleTime()
	      .domain([start, end])
	      .range([0, width]);

	  y = d3.scaleLinear()
	      .domain([minCurrent, maxCurrent])
	      .range([height, 0]);

	  // x-axis
	  svg.append("g")
	      .attr("transform", "translate(0," + height + ")")
	      .classed("tide-plot-x-axis", true)
	      .call(d3.axisBottom(x));

	  // y-axis
	  svg.append("g")
	      .classed("tide-plot-y-axis", true)
	      .call(d3.axisLeft(y)
		    .tickArguments([parseInt((maxCurrent - minCurrent) - 1)]));

	  // y-axis gridlines
	  svg.append("g")			
	      .classed("tide-plot-grid", true)
	      .call(d3.axisLeft(y)
		    .tickSize(-width)
		    .tickFormat("")
		    .ticks([parseInt((maxCurrent - minCurrent) - 1)])
		   );
	  
	  // Current speed
	  svg.append("path")
	      .datum(data)
	      .classed("tide-plot-tide", true)
	      .attr("d", d3.area()
		    .x(function(d) { return x(d[0]) })
		    .y1(function(d) { return y(d[1]) })
		    .y0(function(d) { return y(0) })
		    .curve(d3.curveBasis)
		   );

	  // Max flow & slack grid lines
	  const event_times = [];
	  for (i in plot_events) {
	      const item = plot_events[i];
	      t = new Date(item.t);
	      if ((t > start) && (t < end)) {
		  event_times.push(t);
	      }
	  }
	  svg.append("g")			
	      .classed("tide-plot-grid", true)
	      .call(d3.axisBottom(x)
		    .tickSize(height)
		    .tickFormat("")
		    .tickValues(event_times)
		   );

	  // Max flow & slack labels
	  X = plot_events.map(function(d) { return(Date.parse(d.t)); });
	  Y = plot_events.map(function(d) { return(d.v); });
	  data = [];
	  for (i in X) {
	      if ((X[i] > start) && (X[i] < end)) {
		  let label = (parseFloat(plot_events[i].v).toFixed(1) + "kt @" + plot_events[i].t.slice(11));
		  data.push([X[i], parseFloat(Y[i]), label, plot_events[i].e]);
	      }
	  }
	  
	  // Now
	  now = Date.now();
	  svg.append("path")
	      .datum([[now, minCurrent], [now, maxCurrent]])
	      .classed("tide-plot-now", true)
	      .attr("d", d3.line()
		    .x(function(d) { return x(d[0]) })
		    .y(function(d) { return y(d[1]) })
		   );

	  // Labels are drawn over Now line
	  svg.append("g")
	      .classed("tide-plot-label-group", true)
	      .selectAll('text')
	      .data(data)
	      .enter()
	      .append("g")
	      .attr("opacity", 1)
	      .classed("tide-plot-label", true)
	      .classed("label", true)
	      .attr("transform", function(d, i) {
		  return("translate(" + x(d[0]) + ", " + y(d[1]) + ")")
	      })
	      .append('text')
	      .classed("current-plot-label-item", true)
	      .classed("label", true)
	      .attr("text-anchor", "middle")
	      .attr("dx", 0)
	      .attr("dy", function(d, i) { return(d[3] == "Max Flood" ? "-0.45em" : "1.3em") } )
	      .text(function(d, i) { return(d[2]); });

	  d3.selectAll(".current-plot-label-item").each(function(e, i) {
	      let label = d3.select(this);
	      let parent = this.parentNode;
	      let bbox = label.node().getBBox();
	      d3.select(parent).insert("rect", ":first-child")
	          .attr("x", function(d, i){return bbox.x})
		  .attr("y", function(d, i){return bbox.y})
		  .attr("dx", 0)
		  .attr("dy", function(d,i) { return(data[i][3] == "Max Flood" ? "-0.4em" : "1.3em") } )
		  .attr("width", function(d){return bbox.width})
		  .attr("height", function(d){return bbox.height})
		  .classed("current-plot-label-background", true);
	  });
      }

      function fetchTidesAndCurrents() {
	  const url = "data/NOAA/tides.json";
	  d3.json(url)
	      .then(
		  function(json) {  tideData = json; plotTides(); plotCurrents(); },
		  function(error) { console.log("Couldn't fetch tides from url: " + url) }
	      );
      }

      /* The NOAA web server's CORS setting prevents using the data directly in a web page.
	 const noaaTideURL = 'https://tidesandcurrents.noaa.gov/api/datagetter?station=&begin_date=&end_date=&applications=StFYC&product=predictions&datum=MLLW&units=english&time_zone=lst_ldt&format=json';

	 function fetchTidesAndCurrents() {
	 t = new Date();
	 let year = t.getFullYear().toString();
	 let month = (t.getMonth() < 9 ? "0" : "") + (t.getMonth()+1).toString();
	 let date = (t.getDate() < 10 ? "0" : "") + t.getDate().toString();
	 const hour = t.getHours();
	 const minute = t.getMinutes();
	 const begin_date = year + month + date;
	 t.setTime(t.getTime() + (24 * 60 * 60 * 1000));
	 year = t.getFullYear().toString();
	 month = (t.getMonth() < 9 ? "0" : "") + (t.getMonth()+1).toString();
	 date = (t.getDate() < 10 ? "0" : "") + t.getDate().toString();
	 const end_date =  year + month + date;
	 
	 let url = noaaTideURL.replace("station=", "station=" + noaaTideStation)
	 url = url.replace("begin_date=", "begin_date=" + begin_date)
	 url = url.replace("end_date=", "end_date=" + end_date);
	 let tides = "";
	 let currents = "";
	 
	 d3.json(url)
	 .then(
	 function(json) { tides = json },
	 function(error) { console.log("Couldn't fetch tides from url: " + url) }
	 );
	 url = url + "&interval=hilo";
	 d3.json(url)
	 .then(
	 function(json) { currents = json },
	 function(error) { console.log("Couldn't fetch currents from url: " + url) }
	 );
	 graphTidesAndCurrents(tides, currents);
	 }
      */

      function setCurrentChartURL() {
	  // Advance one hour from now and construct forecast URL
	  t = new Date()
	  t.setTime(Date.now() + (60 * 60 * 1000))
	  // https://cdn.tidesandcurrents.noaa.gov/ofs/sfbofs/wwwgraphics/SFBOFS_entrance_cu_fore_202206080100.png
	  const year = t.getFullYear();
	  const month = t.getMonth();
	  const date = t.getDate();
	  const hour = t.getHours();
	  const minute = t.getMinutes();

	  ts = year;
	  ts += (month < 10) ? "0" + (month+1) : (month+1);
	  ts += (date < 10) ? "0" + date : date;
	  ts += (hour < 10) ? "0" + hour : hour;
	  ts += "00"
	  
	  url = "https://cdn.tidesandcurrents.noaa.gov/ofs/sfbofs/wwwgraphics/SFBOFS_entrance_cu_fore_" + ts + ".png";
	  d3.select("#sfCurrentChart").attr("src", url).attr("sfCurrentChart-data-hour", hour).attr("sfCurrentChart-data-minute", minute);;
      }

      function updateImg(e) {
	  let url = d3.select(e).attr("src");
	  let q = url.lastIndexOf("?");
	  const now = Date.now();
	  if (q == -1) {
	      url += "?" + now;
	  } else {
	      url = url.substr(0, q+1) + now;
	  }
	  //console.log("updateImage new url: " + url);
	  d3.select(e).attr("src", url);
      }
      
      // https://web.dev/lazy-loading-video/
      const lazyVideoObserver = new IntersectionObserver(function(entries, observer) {
	  entries.forEach(function(video) {
	      if (video.isIntersecting) {
		  for (let source in video.target.children) {
		      const videoSource = video.target.children[source];
		      if (typeof videoSource.tagName === "string" && videoSource.tagName === "SOURCE") {
			  videoSource.setAttribute("src", videoSource.dataset.src);
			  videoSource.removeAttribute("data-src");
		      }
		  }

		  console.log("lazyVideoObserver start " + video.target.id);
		  video.target.classList.remove("lazy");
		  lazyVideoObserver.unobserve(video.target);
		  video.target.load();
		  video.target.play();
	      }
	  });
      });
	      
      function initializeVideoLazyLoad() {
	  const lazyVideos = [].slice.call(document.querySelectorAll(".wx-video.lazy"));
	  lazyVideos.forEach(function(lazyVideo) {
	      lazyVideoObserver.observe(lazyVideo);
	  });
      }

      function updateVideo(e) {
	  if (e == null) {
	      return;
	  }

	  for (let source in e.children) {
	      const videoSource = e.children[source];
	      if (typeof videoSource.tagName === "string" && videoSource.tagName === "SOURCE") {
		  let src = videoSource.src;

		  if (src == null || src == "") {
		      //console.log("updateVideo video not loaded");
		      return;
		  }

		  let url = src.substring(0, src.lastIndexOf("/")) + "/latest.json?" + Date.now();
		  console.log("updateVideo fetch src '" + src + "' url " + url);
		  d3.json(url)
		      .then(
			  function(json) {
			      if (videoSource.src.substr(src.lastIndexOf("/")+1) != json.fn.substr(json.fn.lastIndexOf("/")+1)) {
				  e.pause();
				  console.log("updateVideo " + videoSource.src + " -> " + json.fn);
				  videoSource.setAttribute("data-src", json.fn);
				  videoSource.removeAttribute("src");
				  e.classList.add("lazy");
				  lazyVideoObserver.observe(e);
				  return;
			      }
			      // console.log("updateVideo no change " + src);
			      return;
			  },
			  function(error) {
			      console.log("updateVideo couldn't fetch video filename latest " + url);
			      return;
			  }
		  
		      );
		  return;
	      }
	  }
	  console.log("updateVideo no src found");
      }

      let sceneMenuIsPopped = false;
      function handleScenePullDownClick(e) {
	  if (sceneMenuIsPopped) {
	      d3.select(".wx-sidebar")
		  .classed(".zpop", false)
		  .attr("style", "display: none");
	      sceneMenuIsPopped = false;
	  } else {
	      d3.select(".wx-sidebar")
		  .classed(".zpop", true)
		  .attr("style", "display: block");
	      sceneMenuIsPopped = true;
	  }
      }

      let lastSec = -1;
      let lastMinute = -1;
      function dispatch() {
	  const now = new Date();
	  const time = Math.floor(now.getTime() / 1000);
	  if (time == lastSec) {
	      return;
	  }
	  lastSec = time;

	  if (mode == "Carousel") {
	      rotateScene(); // Called once per second
	  }

	  if (windsNeedRender) {
	      plotTempestWindForecast("St. Francis Yacht Club");
	  }

	  minutes = Math.floor(time/60);
	  if (minutes == lastMinute) {
	      return;
	  }

	  // Everything here and below executes once per minute

	  const hour = now.getHours();
	  const minute = now.getMinutes();
	  console.log(`Dispatch: h ${hour} m ${minute} t ${time/60} l ${lastMinute}`);

	  lastMinute = minutes;

	  // It's a new minute so update the local and GMT clock fields
	  u = now.toUTCString();
	  d3.select("#time-UTC").html( u.slice(17,22) + "UTC");
	  l = now.toTimeString();
	  ts = l.slice(0, 5);
	  tz = l.slice(l.indexOf("(") + 1, l.indexOf(")") - 2);
	  d3.select("#time-local").html( ts + (l.includes("Daylight") ? "PDT" : "PST")); // Kludgey

	  if (mode == "Carousel") {
	      rotateProgram();
	  }

	  tempestCheck(); // Have WebSockets closed?

	  // Check the video .json files each minute to see if there is a new render
	  d3.selectAll(".wx-video").each(function() { updateVideo(this) });

	  // Using WebSocket now?
	  //fetchTempestCurrent("St. Francis Yacht Club");
	  //fetchTempestCurrent("Tinsley Island");

	  // Every 5 minutes - Skew it so it's not right on the hour
	  if (!((minute+1) % 5)) {
	      console.log("dispatch 5: " + now);
	      d3.selectAll(".wx-image.update5").each(function() { updateImg(this) });
	      fetchObs(localObs);
	      fetchTempestHistory("St. Francis Yacht Club");
	      fetchTidesAndCurrents();
	  }

	  // Every 10 minutes - Skew it so it's not right on the hour
	  if (!((minute+4) % 10)) {
	      // Doesn't happen very often
	      fetchNWS();
	  }
	  
	  if (minute > 30) {
	      // Change current chart once per hour after half-past.
	      /*
		if (hour != d3.select("#sfCurrentChart").attr("sfCurrentChart-data-hour")) {
		//setCurrentChartURL();
		}
	      */
	  }

	  if (!((minute + 3) % 60)) {
	      fetchTempestForecast("St. Francis Yacht Club");
	  }
      }

      let wastedSize = 0;
      
      function initializeScene(newScene) {
	  const now = new Date();
	  const time = Math.floor(now.getTime() / 1000);

	  curScene = newScene;
	  
	  d3.selectAll(".wx-scene").classed("show", false);
	  while (scenes[curScene].duration == 0) { // Skip scenes with 0 duration
	      curScene = (curScene + 1) % scenes.length;
	  }

	  let list = d3.select("#scene-list").property("children");
	  for (i = 0; i < list.length; i++) {
	      d3.select(list[i]).classed("bg-active", (i==curScene) ? true : false);
	  }
	  
	  d3.select("#" + scenes[curScene].div).classed("show", true);

	  if (scenes[curScene].div == "vesselFinderScene") {
	      let el = document.getElementById(scenes[curScene].div);
	      if ( el === undefined ) {
		  el = document.documentElement;
	      }
	      wastedSize = el.offsetHeight;
	      $(window).trigger('resize');
	  }
	  curSceneTime = time;
	  console.log(`initializeScene program: ${schedule[curProgram].program} scene: ${scenes[curScene].div} time left: ${(curSceneTime + scenes[curScene].duration) - time}`);
      }

      function rotateScene() {
	  if (scenes.length == 0) {
	      console.log("rotateScene called before scenes initialized");
	      return;
	  }
	  
	  const now = new Date();
	  const time = Math.floor(now.getTime() / 1000);

	  if (time < (curSceneTime + scenes[curScene].duration)) {
	      return;
	  }

	  curScene = (curScene + 1) % scenes.length;

	  if (highWindMode) {
	      // squirrel away curScene - is this needed? can resume from curScene?
	      highWindCurScene = curScene;
	      return;
	  }
	  
	  initializeScene(curScene);
      }

      function initializeProgram(p) {
	  curProgram = p;
	  program = schedule[curProgram].program
	  console.log("Rotate Program to " + program);
	  scenes = programs[program];
	  curSceneTime = 0;
	  curScene = scenes.length - 1;

	  // Create scene list
	  d3.select("#program").html(program);
	  const list = d3.select("#scene-list");
	  list.selectAll("*").remove();
	  scenes.forEach(function(sc,i) {
	      let b = list.append("div")
		  .attr('id', "scene-index-" + i)
		  .html(sc.label);
	      if (sc.div == "") {
	      	  b.classed('scene-not-button', true);
	      } else {
	      	  b.classed('scene-button', true);
	      }
	  });
      }

      function rotateProgram() {
	  const now = new Date();
	  const m = now.getMinutes();

	  let curStart = schedule[curProgram]["start"];
	  let nextProgram = (curProgram+1) % schedule.length;
	  let nextStart = schedule[nextProgram]["start"];
	  let newProgram = curProgram;
	  console.log(`rotateProgram: -${m} curProgram ${curProgram} curStart ${curStart} nextProgram ${nextProgram} nextStart ${nextStart}`);
	  while (((m < curStart) && (m >= nextStart)) ||          // Time wrapped to next hour
		 ((nextStart >= curStart) && (m >= nextStart))) { // Not wrapping
	      console.log(`rotateProgram: +${m} curProgram ${curProgram} curStart ${curStart} nextProgram ${nextProgram} nextStart ${nextStart}`);
	      newProgram = nextProgram;
	      curStart = nextStart;
	      nextProgram = (newProgram+1) % schedule.length;
	      nextStart = schedule[nextProgram]["start"];
	  }

	  if (newProgram != curProgram) {
	      initializeProgram(newProgram);
	  }
      }

      function initializeLocalObs() {
	  // Table header row
	  const r = d3.select("#" + localObs["tableId"]).append("div").attr("id", localObs["tableId"] + "-header").classed("obs-header", true)
	  for (let i = 0; i < localObs["displayFields"].length; i++) {
	      const f = localObs["displayFields"][i];
	      r.append("div")
		  .classed("obs-table-cell", true)
		  .classed(f["style"], true)
		  .html(f["label"]);
	  }

	  const bodyId = localObs["tableId"] + "-body";
	  const b = d3.select("#" + localObs["tableId"]).append("div").attr("id", bodyId).classed("obs-body", true)
	  for (let s = 0; s < localObs["stations"].length; s++) {
	      var stid;
	      const STID = localObs["stations"][s];
	      const firstCharacter = STID.charAt(0);
	      if (((firstCharacter >= 'A') && (firstCharacter <= 'Z')) || ((firstCharacter >= 'a') && (firstCharacter <= 'z'))) {
		  stid = STID;
	      } else {
		  // Prepend a 'B' for buoys
		  stid = 'B' + STID;
	      }

	      const r = b.append("div").attr("id", stid).attr("class", "obs-row");
	      // Add an element for each field
	      for (let i = 0; i < localObs["displayFields"].length; i++) {
		  const f = localObs["displayFields"][i];
		  const id = stid + '_' + f["field"];
		  r.append("div")
		      .attr("id", id)
		      .classed("obs-table-cell", true)
		      .classed(f["style"], true)
	      }
	      // Insert station ID field
	      d3.select("#" + stid + "_id").html(STID);
	  }

	  d3.selectAll(".obs-row:nth-child(2n+1)").classed("obs-table-even", true);
	  d3.selectAll(".obs-row:nth-child(2n+2)").classed("obs-table-odd", true);
      }

      function setCarouselMode(m) {
	  console.log("setCarouselMode to " + m);
	  if (m == "Carousel") {
	      mode = "Carousel";
      	      d3.select("#mode-button")
		  .html("Auto");
	      d3.selectAll("#scene-list>div")
		  .classed("active-scene", false)
		  .on('click', null);
	  } else {
	      mode = "Interactive";
      	      d3.select("#mode-button")
		  .html("Interactive");
	      d3.selectAll("#scene-list>div:not(.scene-not-button)")
		  .classed("active-scene", true)
		  .on('click', handleSceneClick);
	  }
      }

      function handleSceneClick(e) {
	  const id = e.target.id;
	  const indexStart = id.lastIndexOf('-')+1;
	  const index = parseInt(id.slice(indexStart));
	  initializeScene(index);
      }

      function handleModeButton() {
	  if (mode == "Carousel") {
	      setCarouselMode("Interactive");
	  } else {
	      setCarouselMode("Carousel");
	  }
      }

      function visibilityChange() {
	  if (!document.hidden) {
	      anemometer.render();
	      //windPlotHistory("wind-history-recent", windHistory);
	      plotTempestWindForecast("St. Francis Yacht Club");
	      //plotTides();
	      //plotCurrents();
	  }
      }

      function initialize() {
	  console.log("Initializing wx page");
	  initializeLocalObs();

	  let href = window.location.href;

	  d3.select(".highWindThreshhold").html(highWindThreshhold);
	  d3.select(".highWindDuration").html(Math.floor(highWindDuration/1000));

	  if (href.indexOf("?kiosk") == -1) {
	      console.log("interactive mode");
	      schedule = interactiveSchedule;
	      initializeProgram(0);
	      d3.select("#mode-button")
		  .attr("style", "display: inline-grid")
		  .on('click', handleModeButton);
	      setCarouselMode("Interactive");
	      curScene = scenes.length - 1;
	      rotateScene();
	  } else {
	      console.log("Kiosk mode");
	      schedule = productionSchedule;
	      initializeProgram(0);
	      setCarouselMode("Carousel");
	      curScene = scenes.length - 1;
	      rotateScene();
	  }

	  fetchObs(localObs);
	  fetchNWS();
	  //setCurrentChartURL();

	  for (let e of document.querySelectorAll(".nws-container")) {
	      nwsRO.observe(e);
	  }
	  
	  leafletRadar = false;
	  if (leafletRadar) {
	      initializeRadar();
	      sfRadarRO.observe(document.querySelector("#sfRadar"));
	  }

	  // Catch resize events for anemometer graphs because I'm too lame to get the svgs to scale
	  windRO.observe(document.querySelector("#localWind"));

	  tidesRO.observe(document.querySelector(".tides-graph"));
	  currentsRO.observe(document.querySelector(".currents-graph"));

	  anemometer = new Gauge('anemometer-stfyc', {
	      classRoot: "anemometer-stfyc",
	      maxValue: 30, // in knots
	      arcColorFn: d3.interpolateHslLong("#613CFF", "#FB4B39"), // nice blue & red hues, gradient centers on green
	      arcSegments: 512, // make dial a smooth rainbow
	      arcMajorTicks: 5,
	      arcLabelFormat: d3.format('d'),
	      pointers: [
		  { pointerWidthPercent: 0.15, pointerHeadLengthPercent: 0.9, pointerTailPercent: 0.04, transitionMs: 1000, val: 0, },
		  { pointerWidthPercent: 0.10, pointerHeadLengthPercent: 0.9, pointerTailPercent: 0.02, transitionMs: 1000, val: 0, },
	      ],
	  });

	  // Use WebSocket for current? Tempest web service is flakey, so use all ways to get data
	  fetchTempestCurrent("St. Francis Yacht Club");
	  fetchTempestCurrent("Tinsley Island");
	  fetchTempestHistory("St. Francis Yacht Club");
	  fetchTempestForecast("St. Francis Yacht Club");

	  initializeTempestStreams();

	  if (typeof local_windURL !== 'undefined') {
	      windURL = local_windURL;
	  }
	  windInitialize(stfycWindCallback);

	  fetchTidesAndCurrents();

	  // OpenLayers frames
	  // initializeCurrentMap(currentMapConfig);
	  initializeNowCOAST(nationalRadarConfig);
	  initializeNowCOAST(localRadarConfig);

	  d3.interval(dispatch, 1 * 1000);
	  document.addEventListener("visibilitychange", visibilityChange);

	  const cloudTops = new GIS(cloudTopsConfig);

	  initializeVideoLazyLoad();

	  d3.selectAll("#scene-pull-down-enable")
		  .on('click', handleScenePullDownClick);

      }
    </script>

  </head>

  <body id="body" class="wx" onload="initialize();" lang="en">
    <div class="wx-page">
      <div id="header" class="wx-header">
	<div>
	  <div id="scene-pull-down-enable" class="scene-pull-down-enable">
	    <image src="data/lib/menu-icon.svg">
	  </div>
          <div class="burgee-small burgee-left">
	    <image src="data/lib/stfyc-burgee.svg"></image>
	  </div>
	</div>
	<div class="local-number wx-header-1">
	  &nbsp;&nbsp;StFYC:&nbsp;<span class="temp-span-stfyc"></span>&#8457;&nbsp;
	  Wind&nbsp;<span class="direction-avg-span-stfyc"></span>&#176M&nbsp;
	  @&nbsp;<span class="wind-span-stfyc"></span>&nbsp;
	  G&nbsp;<span class="gust-span-stfyc"></span>&nbsp;
	  <span id="stfyc-tempest-baro" class="tempest-baro-span-stfyc"></span>mb&nbsp;
	  Tinsley:&nbsp;<span id="tinsley-temp" class="temp-span-tinsley"></span>&#8457;&nbsp;&nbsp;
	</div>
	<div class="local-number wx-header-2">
	  <div>
	    StFYC:&nbsp;<span class="temp-span-stfyc"></span>&#8457;&nbsp;
	    <span class="tempest-baro-span-stfyc"></span>mb&nbsp;
	    Tinsley:&nbsp;<span class="temp-span-tinsley"></span>&#8457;
	  </div>
	  <div>
	  Wind:&nbsp;<span class="direction-avg-span-stfyc"></span>&#176M&nbsp;@<span class="wind-span-stfyc"></span>&nbsp;G&nbsp;<span class="gust-span-stfyc"></span>
	  </div>
	</div>
        <div class="burgee-small burgee-right">
	  <image src="data/lib/stfyc-burgee.svg"></image>
	</div>
      </div>
      
      <div class="wx-row">
	<div id="sidebar" class="wx-sidebar">
	  <div style="display: block;">
	    <div id="program" class="wx-program"></div>
	    <div id="scene-list" class="wx-scene-list"></div>
	  </div>
	  <div class="vertical-spacer-outer">
	    <div class="vertical-spacer-inner"> </div>
	  </div>
	  <div style="display: block">
	    <div id="mode-button" class="wx-button">Auto</div>
	    <div id="time-UTC" class="wx-time"></div>
	    <div id="time-local" class="wx-time"></div>
	  </div>
	</div>
	
	<div id="content" class="wx-content">

<!--
	  <div id="sfLocal" class="wx-scene">
	    <div class="obs-grid">
	      <div class="obs-cell">
		<div id="sfLocalNOAA" style="flex: 1 1 auto; width: 1800px; height: 1000px; max-width: 100%; max-height: 100%"></div>
	      </div>
	    </div>
	  </div>
-->
	  
	  <div id="sfbofs" class="wx-scene">
	    <div class="obs-grid">
	      <div class="obs-cell">
		<div id="sfRadar" style="width: 100%; height: 1000px; flex: 1 1 max-content;"></div>
	      </div>
	    </div>
	  </div>

	  <div id="sfLocalObservations" class="wx-scene">
	    <div class="ol-flex-fit" style="flex-direction: column;">
	      <div class="obs-grid">
		<div class="obs-cell">
		  <div class="label">Local Observations</div>
		  <div id="sfLocalObservationsTable" class="obs-table"></div>
		</div>
	      </div>
	      <div class="ol-flex-fit" style="flex-direction: column;">
		<div class="label">Local Radar & Warnings</div>
		<div class="ol-flex-fit">
		  <div id="localRadar" class="ol-flex-fit">
		    <div id="localRadarLabel" class="ol-label">Local NEXRAD Radar</div>
		  </div>
		</div>
	      </div>
	    </div>
	  </div>

	  <div id="ZoneForecasts" class="wx-scene">
	    <div id="nws-2" class="nws-column-2">
	      <div class="wx-cell" style="overflow: hidden">
		<div class="grid-container" style="vertical-align: top">
		  <div id="nws-zoneForecasts" class="nws-column">
		    <div id="nws-2-zone-container" class="nws-zone-container nws-container"></div>
		  </div>
		  <div id="nws-afd" class="nws-column">
		    <div id="nws-2-afd-container" class="nws-afd-container nws-container"></div>
		  </div>
		</div>
	      </div>
	    </div>
	    <div id="nws-1" class="nws-container nws-column-1">
	      <div class="grid-container" style="vertical-align: top">
		<div class="nws-column">
		  <div class="nws-zone-container"></div>
		  <div class="nws-afd-container"></div>
		</div>
	      </div>
	    </div>
	  </div>

	  <div id="localWind" class="wx-scene localWind">
	    <div class="wind-grid">
	      <div class="wind-cell">
		<div id="anemometer-stfyc-label" class="label">StFYC Race Office Wind</div>
		<div id="anemometer-stfyc" class="anemometer-cell"></div>
		<div id="anemometer-stfyc-plot-label" class="anemometer-stfyc-plot-label anemometer-cell horizontal-center">
		    Wind <span class="direction-avg-span-stfyc"></span>&#176M @<span class="wind-span-stfyc"></span> Gust <span class="gust-span-stfyc"></span>&nbsp;kts
		</div>
	      </div>
	      <div class="wind-cell">
		<div class="wind-row">
		  <div>
		    <div id="wind-history-recent-label" class="label">Race Office 6hr Wind History</div>
		    <div id="wind-history-recent" class="wind-plot"></div>
		  </div>
		  <div>
		    <div id="wind-forecast120-label" class="label">WeatherFlow 5-Day Wind Forecast</div>
		    <div id="wind-forecast120" class="wind-plot"></div>
		  </div>
		</div>
	      </div>
	    </div>
	  </div>
	  
	  <div id="sfTides" class="wx-scene">
	    <div class="tides-grid">
	      <div class="tides-cell">
		<div id="tide-forecast-9414290-label" class="label">Tide Height @ Ft Point</div>
		<div id="tide-forecast-9414290" class="tides-graph"></div>
	      </div>
	      <div class="tides-cell">
		<div id="current-forecast-SFB1203_18-label" class="label">Tidal Current 0.46nm E of Golden Gate Bridge (depth 30ft)</div>
		<div id="current-forecast-SFB1203_18" class="currents-graph"></div>
	      </div>
	      <div class="tides-cell">
		<div class="label">NOAA SFBOFS Currents</div>
		<div><img id="sfCurrentChart" class="wx-image update5" alt="current chart SFB1202" src="data/SFBOFS/latest.png"></div>
	      </div>
	      <div id="current-events-SFB1203_18" class="tides-cell">
		<div class="label">Today @ 0.46nm E of Golden Gate Bridge (depth 30ft)</div>
		<div id="current-events-content-SFB1203_18" class="current-events-content"></div>
		<!--
		    <span class="h3">Current Prediction @ GG Bridge</span><br>
		    <img class="wx-image update5" alt="current plot SFB1202" src="https://cdn.tidesandcurrents.noaa.gov/ports/plots/SFB1202_cu_24.png">
		    -->
	      </div>
	    </div>
	  </div>
	  
	  <div id="pacificSurfaceAnalysis" class="wx-scene wx-image">
	    <div class="wx-cell">
	      <img class="wx-image update5" alt="Pacific Surface Analysis" src="https://ocean.weather.gov/P_sfc_full_ocean_color.png">
	    </div>
	  </div>
	  <div id="overlay-WestCoast" class="wx-scene">
	    <img class="wx-image update5" alt="West Coast + Offshore Satellite image" src="data/overlay/WestCoast/latest.jpg">
	  </div>
	  <div id="goes-PACUS" class="wx-scene">
	    <img class="wx-image update5" alt="PACUS image" src="data/GOES/NESDIS_CONUS-West/latest.jpg">
	  </div>
	  <div id="overlay-BayDelta" class="wx-scene">
	    <img class="wx-image update5" alt="Bay/Delta Satellite image" src="data/overlay/BayDelta/latest.jpg">
	  </div>
	  <div id="overlay-NorthPacific" class="wx-scene">
	    <img class="wx-image update5" alt="North Pacific w/ Surface Analysis" src="data/overlay/Pacific/latest.jpg">
	  </div>
	  
	  <div id="video-Pacific" class="wx-scene">
	    <div class="timelapse">
	      <video id="v-Pacifc" class="lazy wx-video" poster="data/overlay/Pacific/latest.jpg" controls="false" autoplay muted playsinline loop>
		<source data-src="data/overlay/Pacific/latest.mp4">
	      </video>
	    </div>
	  </div>
	  
	  <div id="video-WestCoast" class="wx-scene">
	    <div class="timelapse">
	      <video id="v-WestCoast" class="lazy wx-video" poster="data/overlay/WestCoast/latest.jpg" controls="false" autoplay muted playsinline loop>
		<source data-src="data/overlay/WestCoast/latest.mp4">
	      </video>
	    </div>
	  </div>
	  
	  <div id="video-BayDelta" class="wx-scene">
	    <div class="timelapse">
	      <video id="v-BayDelta"  class="lazy wx-video" poster="data/overlay/BayDelta/latest.jpg" controls="false" autoplay muted playsinline loop>
		<source data-src="data/overlay/BayDelta/latest.mp4">
	      </video>
	    </div>
	  </div>

<!--
	  <div id="purpleAir" class="wx-scene">
		<div id='PurpleAirWidget_81675_module_AQI_conversion_C0_average_10_layer_standard'>Loading PurpleAir Widget...</div>
		<script src='https://www.purpleair.com/pa.widget.js?key=BIHHOFMKJ30NI4DB&module=AQI&conversion=C0&average=10&layer=standard&container=PurpleAirWidget_81675_module_AQI_conversion_C0_average_10_layer_standard'></script>
	  </div>
-->

<!--
	  <div id="currentMapScene" class="wx-scene">
	    <div id="currentLabel" class="label"></div>
	    <div id="currentMap" class="ol-flex-fit" width="1280" height="720"></div>
	  </div>
-->
	  
	  <div id="nationalRadarScene" class="wx-scene">
	    <div id="nationalRadarLabel" class="label">National RADAR</div>
	    <div id="nationalRadar" class="ol-flex-fit"></div>
	  </div>

	  <div id="cloudTopsScene" class="wx-scene">
	    <div id="cloudTops" class="ol-flex-fit" width="1280" height="720">
	      <div id="cloudTopsLabel" class="ol-label">
	      </div>
	    </div>
	  </div>

	  <div id="WeatherFlowStFYCScene" class="wx-scene">
	    <iframe src="https://tempestwx.com/station/74155/" class="wxFlow-frame" title="StFYC WeatherFlow Forecast" loading="lazy" allow="fullscreen"></iframe>
	  </div>

	  <div id="WeatherFlowTinsleyScene" class="wx-scene" width="1280" height="720" loading="lazy" allow="fullscreen">
	    <iframe src="https://tempestwx.com/station/42921/" class="wxFlow-frame" title="StFYC WeatherFlow Forecast"></iframe>
	  </div>
<!--
	  <div id="vesselFinderScene" class="wx-scene">
	    <div class="obs-grid">
	      <div class="obs-cell">
		<div id="vesselFinder" class="obs-cell">
		  <script type="text/javascript">
		    {
			var width="100%";         // width in pixels or percentage
			var height="1000";         // height in pixels
			var latitude="37.8400";     // center latitude (decimal degrees)
			var longitude="-122.4150";    // center longitude (decimal degrees)
			var zoom="13";             // initial zoom (between 3 and 18)
			var names=true;
		    }
		  </script>
		  <script type="text/javascript" src="https://www.vesselfinder.com/aismap.js" defer=""></script>
		</div>
	      </div>
	    </div>
	  </div>
-->

	  <div id="linksScene" class="wx-scene">
	    <div id="links" class="text-scene">
	      <h3>Weather Sites</h3>
	      <a href="https://weather.gov/mtr">NWS Bay Area</a> - The Weather Field Office (WFO) in Monterey<br>
	      <a href="https://new.nowcoast.noaa.gov/mariner.html">NOAA nowCOAST</a> - Real-time observations and warnings for mariners & more<br>
	      <a href="https://tropicaltidbits.com">Tropical Tidbits</a> - Dr Levi Cowen's site with many weather models and his excellent storm analysis when appropriate.<br>
	      <a href="https://windy.com">Windy</a> - Excellent display of current weather and models.<br>
	      <a href="https://l-36.com/weather.php?lat=37.82&lon=-122.48&point1=Sausalito,+CA&point2=Marine+Location+Near+Sausalito,+CA&tide1=San+Francisco,+California+(2)+(expired+1998-12-31)&tide2=San+Francisco+Bay+Entrance+(Golden+Gate),+California+Current&lat_long1=37.82,-122.48&radar=MUX&radar2=DAX&station=mtr&ports=9414290&rss=ftpc1&rss2=tibc1&rss3=46237&airport=KSFO&geos=west/wc&lat_long2=37.82,-122.48&yd10=on&zone1=PZZ530&zone2=PZZ500&v=0.50">L-36 Golden Gate</a> - Weather from Lapworth 36 owners<br>
	      <a href="https://www.wunderground.com/">Weather Underground</a> - Started by Dr Jeff Masters, it was a great grass-roots weather site until it was purchased first by The Weather Channel, then by IBM.<br>
	      <a href="https://sailflow.com/map#37.831,-122.453,12,1">SailFlow SF Bay</a> - San Francisco site for SailFlow, a part of WeatherFlow. They also do iWindSurf, iKiteSurf, FishWeather, and WindAlert.<br>
	      <a href="https://sailflow.com/spot/411">Sail Flow Anita Rock</a> - Live data, recent history, and weather forecasts.<br>
	      <a href="https://www.weathernerds.org/">Weather Nerds</a> - 'Nuf said.<br>
	      <a href="https://weather.cod.edu/satrad/">COD Satellite & Radar</a> - College of DuPage Weather Site.<br>
	      <h3>NOAA/NWS Weather</h3>
	      <a href="https://weather.gov">NWS Main Page</a> - The National Weather Service<br>
	      <a href="https://weather.gov/mtr">NWS Bay Area</a> - The Weather Field Office (WFO) in Monterey<br>
	      <a href="http://www.wrh.noaa.gov/map/?&zoom=5&scroll_zoom=false&center=40,-97&boundaries=false,false,false,false,false,false,false,false,false,false,false&tab=layers&hazard=true&hazard_type=all&hazard_opacity=60&elements=temp,wind,gust&temp_filter=-80,130&gust_filter=0,150&rh_filter=0,100&elev_filter=-300,14000&precip_filter=0.01,30&obs_popup=false&obs_density=60&obs_provider=ALL&radar=true&radar_min=20&radar_loop=false&radar_opacity=70">NWS US Map</a> - The Continental US (CONUS) w/ radar & warning area overlays.<br>
	      <a href="https://weather.gov/ncep">NCEP Main Page</a> - The National Center for Environmental Prediction<br>
	      <a href="https://www.wpc.ncep.noaa.gov">WPC Main Page</a> - The Weather Prediction Center<br>
	      <a href="https://ocean.weather.gov">OPC Main Page</a> - The Ocean Prediction Center<br>
	      <a href="https://spc.noaa.gov">SPC Main Page</a> - The Storm Prediction Center<br>
	      <a href="https://ocean.weather.gov/Pac_tab.php">NOAA OPC Pacific</a> - Ocean Prediction Center North Pacific.<br>
	      <a href="https://www.weather.gov/marine/radiofax_charts">NOAA Radiofax</a> - Old School Radiofax Charts as broadcast over shortwave.<br>
	      <a href="https://www.ospo.noaa.gov/Products/ocean/sst/contour/">OSPO SST</a> - Sea Surface Temperature from satellite observations.<br>
	      <a href="https://www.ospo.noaa.gov/data/sst/contour/californ.c.gif">SST California Coast</a> - Local SST Analysis.<br>
	      <a href="https://www.ndbc.noaa.gov/">NDBC</a> - The National Data Buoy Center<br>
	      <a href="https://www.ndbc.noaa.gov/station_page.php?station=46026">NDBC SF Approach</a> - Buoy 46026 north of the Light Bucket<br>

	      <h3>NOAA/NWS Modeling</h3>
	      <a href="https://www.emc.ncep.noaa.gov/">NOAA NCEP</a> - The National Center for Environmental Prediction<br>
	      <a href="https://www.mmm.ucar.edu/models/wrf">NCAR WRF</a> - National Center for Atmospheric Reaerch WRF model<br>
	      <a href="https://nomads.ncep.noaa.gov/">NOMADS</a> - NOAA Operational Model Archive and Distribution System - the model repository<br>
	      
	      <h3>Tides & Currents</h3>
	      <a href="https://tidesandcurrents.noaa.gov/">NOAA's Tides & Currents</a> - <br>
	      <a href="https://tidesandcurrents.noaa.gov/tide_predictions.html">NOAA Tide Predictions</a> - <br>
	      <a href="https://tidesandcurrents.noaa.gov/ports/index.html?port=sf">NOAA PORTS </a> - San Francisco Bay<br>
	      <a href="https://tidesandcurrents.noaa.gov/ofs/sfbofs/sfbofs.html">NOAA OFS</a> - SF Bay Operational Forecast System<br>

	      <h3>Satellite Images</h3>
	      <a href="https://www.star.nesdis.noaa.gov/goes/conus.php?sat=G17">GOES West PACUS</a> - NOAA's repository at NESDIS STAR<br>
	      <a href="https://rammb-slider.cira.colostate.edu/?sat=goes-17&sec=conus&x=7269&y=3770&z=4&angle=0&im=12&ts=1&st=0&et=0&speed=130&motion=loop&maps%5Bborders%5D=white&lat=0&p%5B0%5D=geocolor&opacity%5B0%5D=1&pause=20220527120617&slider=-1&hide_controls=0&mouse_draw=0&follow_feature=0&follow_hide=0&s=rammb-slider&draw_color=FFD700&draw_width=6">GeoColor GOES West image of Bay Area</a> - From RAMMB / CIRA at Colorado St University<br>
	      <a href=""></a> - <br>
	    </div>
	  </div>
	  
	  <div id="aboutScene" class="wx-scene">
	    <div class="text-scene">
	      <span class="about-h2">About the Content</span>
	      <p>
		"Everybody talks about the weather but nobody does anything about it" - <a href="https://quoteinvestigator.com/2010/04/23/everybody-talks-about-the-weather/">Charles Dudley Warner</a>
	      </p>
	      <hr>
	      <div><img src="/images/current_conditions.jpg" class="about-image"></div>
	      <span class="about-h3">Current Conditions</span>
	      <p>
		The current conditions shown at the top of the page come directly from sensors at StFYC and Tinsley Island.
	      </p>
	      <p>
		An <a href="https://airmar.com/productdescription.html?id=160">Airmar PB-200</a> above the Race Office has
		an ultrasonic doppler-based anemometer, thermometer, barometer, and several other sensors. It sends data once
		per second via NMEA-0183 to a computer over a RS-422 4800 Baud serial line (read and interpreted by bespoke StFYC
		software).
	      </p>
	      <p>
		A <a href="https://weatherflow.com/tempest-weather-system/">WeatherFlow Tempest</a> weather station above the
		Clippership Room and another on Tinsley Island have sensors for wind, rain, sunlight, temperature,
		barometric pressure, and lightning. Wind data is sent via WiFi every three seconds to a local system and WeatherFlow's
		network while other data is sent once per minute. Tinsley data comes via WeatherFlow's cloud-based APIs.
	      </p>
	      <p>
		We use the Airmar for wind and the Tempests for temperature and barometric pressure. If the Tempests are not providing
		data the system falls back to nearby NOAA sites and there will be an asterisk next to the readings.
	      </p>
	      <hr>
	      <div><img src="/images/wind.jpg" class="about-image"></div>
	      <span class="about-h3">Wind</span>
	      <p>
		Current wind and recent wind history are from the Airmar above the Race Office. Wind strength is averaged over the
		last two minutes and gusts are the highest 1-second reading in the past two minutes.
	      </p>
	      <p>
		If a gust has been over <span class="highWindThreshhold"></span>kts in the last <span class="highWindDuration"></span> seconds
		the display will switch to the wind display and the wind history graph's Y-axis increases to 45kts.
	      </p>
	      <p>
		As of this writing the Airmar wind strength seems to be fairly accurate when the wind is above ~5kts while the Tempest
		always reads low. Neither give accurate wind direction. Inaccuracies are probably due to sensor location and may be
		addressed in the future by putting the Airmar on a taller mast.
	      </p>
	      <p>
		Wind forecasts are from <a href="https://weatherflow.com">WeatherFlow</a>.
	      </p>
	      <hr>
	      <div><img src="/images/observations.jpg" class="about-image"></div>
	      <span class="about-h3">Observations</span>
	      <p>
		Current weather observations come from <a href="https://synopticdata.com/">Synoptic Data</a> which is contracted
		by the US Government to gather weather data from many sources and make it available for free via a web API. This
		database does not seem to be updated as frequently as the sensor sites so it may be a bit stale.
	      </p>
	      <p>
		Local radar and warnings are from NOAA's <a href="https://radar.weather.gov/">NEXRAD</a> composite
		system and the National Weather Service (NWS).
	      </p>
	      <hr>
	      <div><img src="/images/tide+current.jpg" class="about-image"></div>
	      <span class="about-h3">Tides & Currents</span>
	      <p>
		Tidal data is from <a href="https://tidesandcurrents.noaa.gov/stationhome.html?id=9414290">NOAA's tide station at Ft Point</a>
		which has been in operation since the Civil War. Currents are
		<a href="https://tidesandcurrents.noaa.gov/ofs/ofs_station.html?stname=E%20of%20Golden%20Gate%20Bridge&ofs=sfb&stnid=SFB1203&subdomain=en">
		  modeled at a point just inside the Golden Gate Bridge</a> by NOAA's Operational Forecast System (OFS).
		Beware - the local tide book uses a point just outside the GG Bridge close to Pt Diablo.
		Some current timings and astronomical data come from the <a href="https://flaterco.com/xtide/">XTide</a>
		program which implements NOAA's harmonic tidal model.
	      </p>
	      <hr>
	      <span class="about-h3">SFBay Currents</span>
	      <p>(Not Currently Active)</p>
	      <p>
		The SF Bay current graphics are from NOAA's
		<a href="https://tidesandcurrents.noaa.gov/ofs/sfbofs/sfbofs_info.html">SF Bay Operational Forecast System (OFS or SFBOFS)</a>
		which runs a numerical model of bay tides/currents every six hours and produces hourly forecasts.
	      </p>
	      <hr>
	      <div><img src="/images/nws_forecast.jpg" class="about-image"></div>
	      <span class="about-h3">NWS Forecasts</span>
	      <p>
		Text forecasts for the Bay Area and nearby waters are produced by the National Weather Service (NWS)
		<a href="https://www.weather.gov/mtr/">SF Bay Weather Field Office (WFO)</a> in
		Monterey which develops and runs some of the Navy's weather models.
	      </p>
	      <hr>
	      <span class="about-h3">WeatherFlow Forecasts</span>
	      <p>
		<a href="https://weatherflow.com/">WeatherFlow</a> combines the data it gathers from customer weather stations with NOAA
		models to produce forecasts tailored to customer locations and different activities. They also
		run the popular sports weather web sites and apps
		<a href="https://sailflow.com/">SailFlow</a>,
		<a href="https://wx.iwindsurf.com/">iWindSurf</a>, and
		<a href="https://wx.ikitesurf.com/">iKiteSurf</a>.
	      </p>
	      <hr>
	      <div><img src="/images/sfc_analysis.jpg" class="about-image"></div>
	      <span class="about-h3">Surface Analysis</span>
	      <p>
		The surface analysis chart is produced by human forecasters at
		<a href="ocean.weather.gov">NOAA's Ocean Prediction Center (OPC)</a>. They have other predictive charts
		for the North Pacific (and elsewhere) that go out ~96 hours.
	      </p>
	      <hr>
	      <div><img src="/images/sat_image.jpg" class="about-image"></div>
	      <span class="about-h3">Satellite Images & Time-lapse Movies</span>
	      <p>
		GOES-WEST (aka GOES-18) satellite images come from the
		<a href="https://www.nesdis.noaa.gov/">National Environmental Data and Information Service (NESDIS)</a>
		repository. Raw images are processed (reprojected to Mercator, cropped, etc) using
		<a href="https://github.com/lanceberc/GOES/blob/master/GOES_GDAL.ipynb">locally-developed image processing code</a>.
		The <a href="https://rammb-slider.cira.colostate.edu/?sat=goes-17">GeoColor algorithm</a> used to color the images was developed at
		<a href="https://www.cira.colostate.edu/">CIRA/RAAMB</a>.
	      </p>
	      <p>
		Time-lapse MPEG movies are created locally from the satellite images using <a href="https://ffmpeg.org/">FFmpeg</a>.
	      </p>
	      <hr>
	      <span class="about-h3">National Radar & Warnings, Cloud Tops</span>
	      <p>
		NOAA has made an effort  to make its various data and forecast products available on
		the Internet in many forms. The National Radar map overlays recent NEXRAD radar mosaics on top of current hazard,
		watch, and warning areas. More information is available from NOAA's
		<a href="https://nowcoast.noaa.gov/mariner.html">NowCOAST</a> and
		<a href="https://www.wrh.noaa.gov/map/?&zoom=14&scroll_zoom=false&center=39.198404895765826,-120.23180007934572&boundaries=false,false,false,false,false,false,false,false,false&tab=observation&obs=true&obs_type=air_temp&obs_popup=true&obs_density=10&obs_provider=ALL">Weather & Hazards</a> data viewers.
	      </p>
	      <hr>
	      <span class="about-h3">Data Ingestion and Processing</span>
	      <p>
		All data is ingested and processed on a <a href="https://www.raspberrypi.org/">Raspberry Pi 4</a>
		at StFYC which also runs the web & websocket servers that provide these pages.
		<a href="https://www.github.com/lanceberc/ycwx">Scripts and programs</a> are written in C, bash, Python, and Go.
	      </p>
	      <hr>
	      <span class="about-h3">Web Page, Map Display and Graphing</span>
	      <p>
		These web pages are written using a combination of raw HTML, CSS, and Javascript (aka ECMAscript) with help from the
		<a href="d3js.org":>D3</a> graphing and data manipulation package and the <a href="https://openlayers.org/">OpenLayers</a> &
		<a href="https://www.arcgis.com/">ESRI ArcGIS</a> mapping packages.
	      </p>
	    </div>
	  </div>
	</div>
      </div> <!-- content -->
    </div> <!-- page -->
  </body>
</html>
